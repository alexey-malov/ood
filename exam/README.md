# Вопросы к экзамену

- [Вопросы к экзамену](#вопросы-к-экзамену)
  - [Паттерны проектирования](#паттерны-проектирования)
    - [Паттерн проектирования "Стратегия"](#паттерн-проектирования-стратегия)
    - [Паттерн проектирования "Наблюдатель"](#паттерн-проектирования-наблюдатель)
    - [Паттерн проектирования "Декоратор"](#паттерн-проектирования-декоратор)
    - [Паттерн проектирования "Абстрактная фабрика"](#паттерн-проектирования-абстрактная-фабрика)
    - [Паттерн проектирования "Фабричный метод"](#паттерн-проектирования-фабричный-метод)
    - [Паттерны проектирования "Команда" и "Хранитель"](#паттерны-проектирования-команда-и-хранитель)
    - [Паттерн проектирования "Адаптер"](#паттерн-проектирования-адаптер)
  - [30 экзаменационных вопросов по паттерну «Адаптер»](#30-экзаменационных-вопросов-по-паттерну-адаптер)
    - [Паттерн проектирования "Шаблонный метод"](#паттерн-проектирования-шаблонный-метод)
    - [Паттерн проектирования "Итератор"](#паттерн-проектирования-итератор)
    - [Паттерн проектирования "Компоновщик"](#паттерн-проектирования-компоновщик)
    - [Паттерн проектирования "Состояние"](#паттерн-проектирования-состояние)
    - [Паттерн проектирования "Заместитель"](#паттерн-проектирования-заместитель)
    - [Паттерн проектирования "Посетитель"](#паттерн-проектирования-посетитель)
    - [Паттерн проектирования "Прототип"](#паттерн-проектирования-прототип)
    - [Паттерн проектирования "Строитель"](#паттерн-проектирования-строитель)
  - [30 экзаменационных вопросов по паттерну Builder](#30-экзаменационных-вопросов-по-паттерну-builder)
    - [Паттерн проектирования "Мост"](#паттерн-проектирования-мост)
    - [Архитектура GUI-приложений. Document-View](#архитектура-gui-приложений-document-view)
    - [Архитектура GUI-приложений. Model-View-Controller](#архитектура-gui-приложений-model-view-controller)
    - [Архитектура GUI-приложений. Model-View-Presenter](#архитектура-gui-приложений-model-view-presenter)
  - [Принципы проектирования ПО](#принципы-проектирования-по)
    - [Отношения между классами](#отношения-между-классами)
    - [Принцип единственной ответственности (SRP)](#принцип-единственной-ответственности-srp)
    - [Принцип открытости-закрытости (OCP)](#принцип-открытости-закрытости-ocp)
    - [Принцип подстановки Лисков (LSP)](#принцип-подстановки-лисков-lsp)
    - [Принцип разделения интерфейса (ISP)](#принцип-разделения-интерфейса-isp)
    - [Принцип инверсии зависимостей (DIP)](#принцип-инверсии-зависимостей-dip)
    - [Компоненты и их сочетаемость](#компоненты-и-их-сочетаемость)

## Паттерны проектирования

### Паттерн проектирования "Стратегия"

- В чём принципиальная разница между умением писать код и умением проектировать систему?
   ⭐⭐
- Почему требования к программным системам почти всегда изменяются, и как это влияет на выбор архитектуры?
   ⭐⭐
- Почему паттерны проектирования не являются «готовыми решениями»?
   ⭐
- Как паттерн «Стратегия» помогает избежать велосипедостроения?
   ⭐⭐
- В каких ситуациях применение паттерна «Стратегия» может быть избыточным или вредным? Приведите пример.
   ⭐⭐⭐
- Какие архитектурные проблемы проявились в начальной реализации «утиного симулятора» при добавлении `Fly()`?
   ⭐⭐
- Почему «локальное изменение кода привело к нелокальным эффектам» — особенно опасная ситуация в командной разработке?
   ⭐⭐
- Почему переопределение `Fly()` и `Quack()` в подклассах плохо масштабируется?
   ⭐⭐
- Какие проблемы в примере с утками относятся к нарушению SRP, а какие — к нарушению OCP?
   ⭐⭐⭐
- Что такое «хрупкий базовый класс» и почему это фундаментальная проблема ООП?
    ⭐⭐⭐
- Почему решение с интерфейсами `Flyable` / `Quackable` и `dynamic_cast` считается архитектурно слабым?
    ⭐⭐
- По каким признакам в существующем коде можно понять, что пора заменить наследование композицией?
    ⭐⭐⭐
- Почему принцип «отделяйте изменяемое от неизменяемого» является ключевым для стратегии?
    ⭐⭐
- Как независимость изменений полёта и кряканья влияет на структуру классов?
    ⭐⭐
- Как принцип *Program to an interface, not an implementation* реально снижает стоимость изменений?
    ⭐⭐⭐
- Дайте развёрнутое определение паттерна «Стратегия» и опишите роли Контекста и Стратегии.
    ⭐⭐
- Почему делегирование поведения снижает связанность системы?
    ⭐⭐
- Какие преимущества и риски даёт динамическая смена стратегии в рантайме?
    ⭐⭐
- В каких случаях Контекст стоит делать интерфейсом, а в каких — конкретным классом?
    ⭐⭐⭐
- Почему возможность переиспользования стратегий другими объектами — признак хорошей абстракции?
    ⭐⭐⭐
- Могут ли стратегии иметь собственное состояние?
    ⭐
- Когда наличие состояния в стратегии — оправданное решение, а когда — симптом вырождающейся архитектуры?
    ⭐⭐⭐
- В чём разница между хранением состояния в Контексте и в Стратегии?
    ⭐⭐
- Почему попытка «хранить всё состояние в Контексте» может привести к плохому дизайну?
    ⭐⭐⭐
- Как принципы YAGNI и KISS влияют на решение о добавлении состояния в стратегию?
    ⭐⭐⭐
- Что означает `const`-метод в интерфейсе стратегии с точки зрения контракта?
    ⭐⭐
- Почему опасно объявлять командные методы стратегии `const`, даже если реализация «умеет» это обойти?
    ⭐⭐⭐
- Как LSP и CQS ограничивают проектирование интерфейсов стратегий в C++?
    ⭐⭐⭐
- В каких случаях допустима логическая константность (`mutable`), и какие архитектурные риски она несёт?
    ⭐⭐⭐
- Кто должен определять интерфейс стратегии — разработчик Контекста или разработчик стратегий? Почему?
    ⭐⭐⭐

### Паттерн проектирования "Наблюдатель"

- Дайте определение паттерна проектирования «Наблюдатель» и опишите проблему, которую он решает. ⭐
- Какие роли выделяются в паттерне «Наблюдатель» и какова ответственность каждой из них? ⭐
- Что означает отношение «один-ко-многим» в контексте паттерна «Наблюдатель»? ⭐
- Приведите пример использования паттерна «Наблюдатель» из реальной жизни, не связанный с программированием. ⭐
- Почему паттерн «Наблюдатель» относят к поведенческим паттернам? ⭐
- В чем заключается основная проблема наивной реализации обновления зависимых объектов (на примере WeatherData)? ⭐⭐
- Почему привязка субъекта к конкретным классам наблюдателей считается плохим архитектурным решением? ⭐⭐
- Какие принципы SOLID нарушаются в наивной реализации WeatherData и почему? ⭐⭐
- Объясните, что означает «инкапсуляция переменной части» и как паттерн «Наблюдатель» помогает её достичь. ⭐⭐
- Почему введение общего интерфейса наблюдателя является ключевым шагом при применении паттерна? ⭐⭐
- В чем состоит идея слабой связанности (loose coupling) и как паттерн «Наблюдатель» её обеспечивает? ⭐⭐
- Опишите жизненный цикл наблюдателя: регистрация, получение уведомлений, отписка. ⭐⭐
- В каких случаях имеет смысл динамически добавлять и удалять наблюдателей во время выполнения программы? ⭐⭐
- Чем модель вытягивания (pull model) отличается от модели проталкивания (push model)? ⭐⭐
- Какие преимущества и недостатки у pull-модели в сравнении с push-моделью? ⭐⭐
- Как реализовать подписку наблюдателей только на интересующие их изменения состояния субъекта? ⭐⭐⭐
- Какие проблемы могут возникнуть, если наблюдатель наблюдает более чем за одним субъектом, и как их решать? ⭐⭐⭐
- Почему важно, чтобы субъект находился в согласованном состоянии перед оповещением наблюдателей? ⭐⭐⭐
- Как паттерн «Шаблонный метод» может использоваться совместно с паттерном «Наблюдатель»? ⭐⭐⭐
- Кто должен инициировать оповещение наблюдателей — субъект или клиент — и какие компромиссы есть у каждого подхода? ⭐⭐⭐
- Какие дополнительные сложности возникают при реализации паттерна «Наблюдатель» в языках без сборщика мусора? ⭐⭐⭐
- Что такое «висячие ссылки» в контексте паттерна «Наблюдатель» и как их избежать? ⭐⭐⭐
- Допустимо ли, чтобы метод Update у наблюдателя возвращал значение, и как это может повлиять на поведение субъекта? ⭐⭐⭐
- В каких случаях наблюдателям разрешается изменять состояние субъекта, и какие риски это несет? ⭐⭐⭐
- Как обеспечить расширяемость системы, не модифицируя код субъекта при добавлении новых типов наблюдателей? ⭐⭐⭐
- В чем отличие классической объектно-ориентированной реализации паттерна от функционального варианта с callback-функциями? ⭐⭐⭐
- Какие преимущества дает использование библиотек сигналов и слотов (например, boost::signals2) по сравнению с ручной реализацией Observer? ⭐⭐⭐
- Как паттерн «Наблюдатель» соотносится с принципом «программируй на уровне интерфейсов, а не реализаций»? ⭐⭐⭐
- В каких ситуациях использование паттерна «Наблюдатель» может привести к ухудшению архитектуры или производительности? ⭐⭐⭐
- Как Наблюдатель может указать, в каких обновлениях он заинтересован? ⭐⭐⭐
- Может ли Субъект выступать в роли Наблюдателя? Может ли Наблюдатель выступать в роли Субъекта? Приведите примеры. ⭐⭐

### Паттерн проектирования "Декоратор"

- Объясните, какую проблему решает паттерн «Декоратор» и почему попытка решить её только наследованием приводит к «комбинаторному взрыву» классов. ⭐⭐
- В чём ключевое отличие «расширения поведения» через декоратор от «расширения поведения» через наследование? Приведите пример из домена «кофейня». ⭐⭐
- Опишите роли участников паттерна Decorator (Component, ConcreteComponent, Decorator, ConcreteDecorator) и сопоставьте их с вашими классами напитков/добавок. ⭐⭐
- Почему важно, что декоратор имеет тот же тип (реализует тот же интерфейс), что и декорируемый объект? Как это связано с полиморфизмом и LSP? ⭐⭐
- Объясните, как в цепочке декораторов вычисляется стоимость напитка (по шагам), и какие гарантии корректности даёт такая структура. ⭐
- Какие признаки подсказывают, что в задаче следует применить декоратор, а не просто добавить методы в базовый класс? ⭐⭐
- Сравните подход «флаги в базовом классе» и подход «декораторы»: какие риски и ограничения есть у каждого, и почему флаги нарушают OCP? ⭐⭐
- Какие «странные комбинации» появляются при реализации через флаги? Как в декораторе можно ограничивать/валидировать недопустимые комбинации? ⭐⭐⭐
- Объясните принцип Open/Closed (OCP) на примере добавления новой добавки (например, «ванильный сироп»): что нужно менять в варианте с флагами и что — в варианте с декоратором? ⭐⭐
- Почему композиция считается более гибкой, чем наследование, в контексте динамического добавления поведения? Приведите пример «во время выполнения». ⭐⭐
- Какие недостатки могут появиться у декоратора по сравнению с наследованием (производительность, отладка, сложность), и как их обычно смягчают? ⭐⭐⭐
- В каких случаях использование декоратора будет избыточным? Назовите критерии и приведите пример. ⭐⭐
- Чем декоратор отличается от прокси и адаптера, если внешне они могут выглядеть похоже (обёртка вокруг объекта)? ⭐⭐⭐
- Почему в `CondimentDecorator` методы `GetDescription()` и `GetCost()` целесообразно сделать `final`? Какие проблемы возникнут, если их разрешить переопределять? ⭐⭐⭐
- Объясните, как в `CondimentDecorator` проявляется паттерн «Шаблонный метод»: где «скелет алгоритма», а где «шаги, делегируемые подклассам»? ⭐⭐
- Почему «шаги алгоритма» (`GetCondimentCost`, `GetCondimentDescription`) можно сделать `private virtual`? Какие архитектурные преимущества это даёт? ⭐⭐⭐
- Как бы вы реализовали «двойную порцию шоколада» в модели с декораторами? Приведите минимум два подхода и сравните их. ⭐⭐
- Какие требования к владению объектом и управлению временем жизни возникают при реализации декоратора? Почему в примере используется `unique_ptr`? ⭐⭐
- Что изменится, если вместо `unique_ptr` использовать `shared_ptr`? Какие новые риски и возможности это создаст для цепочек декораторов? ⭐⭐⭐
- Как декоратор влияет на тестируемость системы? Опишите стратегию юнит-тестирования для базового напитка и для конкретной добавки-декоратора. ⭐⭐
- Как можно реализовать «снятие декорации» (unwrap) или интроспекцию цепочки декораторов, не нарушая инкапсуляцию? ⭐⭐⭐
- Какие ошибки проектирования часто допускают при внедрении декоратора (например, «захардкодить цены в одном месте», «слишком много обязанностей»)? Как их избежать? ⭐⭐⭐
- В примере со строками `StringTransformer` играет роль «интерфейса компонента». Какие свойства должны быть у такого интерфейса, чтобы декораторы хорошо композировались? ⭐⭐
- Почему ручная комбинация преобразователей строк (функции типа `UpperCaseWithSquareBrackets`) приводит к той же проблеме, что и наследование в примере кофейни? ⭐⭐
- Объясните, что делает функция `Decorate(t, d)` в функциональном стиле и как она связана с идеей «оборачивания» в ООП-декораторе. ⭐⭐
- В `Decorate` используется перемещение и `forward`. Какие проблемы с производительностью/корректностью решает perfect forwarding в таком коде? ⭐⭐⭐
- Какой смысл несёт «синтаксический сахар» (например, оператор `|` для строковых декораторов или `<<` для напитков)? Какие риски он несёт для читаемости и поддержки? ⭐⭐
- Приведите пример из реальной разработки, где декоратор используется повсеместно (например, middleware, I/O streams).
  Объясните, как там устроена «цепочка» и что именно добавляют декораторы. ⭐⭐
- Предложите дизайн декоратора для HTTP-клиента, который добавляет авторизацию, логирование и кэширование.
  Как вы определите порядок декораторов и почему? ⭐⭐⭐
- Представьте, что нужно добавить новое требование: «некоторые добавки конфликтуют друг с другом» и «цены зависят от времени суток».
  Как бы вы расширили решение на декораторах? ⭐⭐⭐

### Паттерн проектирования "Абстрактная фабрика"

- Объясните, какую проблему «Абстрактная фабрика» решает лучше, чем «простая фабрика» и «фабричный метод». ⭐⭐
- Что именно скрывает от клиента абстрактная фабрика кроме конкретных классов продуктов? ⭐⭐
- Как «Абстрактная фабрика» помогает соблюдать DIP? Опишите зависимости «до» и «после». ⭐⭐
- Что считается «семейством продуктов» и почему важно создавать их согласованно? ⭐⭐
- В каких случаях абстрактная фабрика превращается в God Factory и как это распознать по симптомам в коде? ⭐⭐
- Опишите стратегию тестирования кода, который использует абстрактную фабрику: что мокается и что проверяется? ⭐⭐
- Почему «неполные семейства» (часть create* не реализована) — архитектурная проблема?
  Какие варианты дизайна решают её? ⭐⭐⭐
- Как добавление нового продукта в семейство (новый метод `CreateX`) влияет на существующий код?
  Как минимизировать ущерб? ⭐⭐⭐
- Когда вместо абстрактной фабрики лучше применить Builder? Опишите критерии выбора. ⭐⭐
- Приведите пример «протекающей абстракции» при использовании абстрактной фабрики и объясните, что это означает. ⭐⭐⭐
- Как организовать выбор конкретной фабрики (NY vs Chicago) так, чтобы бизнес-код не знал о регионах/платформах? ⭐⭐⭐
- Чем опасна фабрика-синглтон с глобальным состоянием в контексте абстрактной фабрики? ⭐⭐
- Как абстрактная фабрика помогает «прибить» совместимость ингредиентов (NY-соус + NY-сыр)?
  Почему это сложно обеспечить без неё? ⭐⭐
- Опишите вариант реализации фабрики в функциональном стиле (через функции/лямбды). Когда это оправдано? ⭐⭐
- Какие параметры допустимо передавать в `IUIFactory::CreateLabel` и какие — недопустимо, и почему? ⭐⭐
- Предложите дизайн API фабрики UI-элементов так, чтобы клиент не передавал платформенные хендлы. ⭐⭐⭐
- Что такое composition root и почему он важен при работе с абстрактными фабриками? ⭐⭐
- Чем «фабрика фабрик» отличается от корректного выбора семейства через composition root? ⭐⭐⭐
- Как бы вы реализовали переключение семейства по feature-flag без протекания деталей в домен? ⭐⭐⭐
- В каких ситуациях допустимо держать в фабрике кэш и состояние? Когда это превращается в проблему? ⭐⭐⭐
- Объясните, как абстрактная фабрика помогает снижать стоимость изменения сигнатур конструкторов продуктов. ⭐⭐
- Какие риски создаёт использование строковых ключей для выбора конкретного продукта внутри фабрики? Чем заменить? ⭐⭐
- Как организовать регистрацию продуктов/креаторов в фабрике, чтобы добавление новых типов не требовало редактирования `if/else`? ⭐⭐
- Приведите пример, когда абстрактная фабрика не нужна, и её использование ухудшит дизайн (YAGNI). ⭐⭐
- Какие признаки того, что вы неправильно выбрали «ось вариативности» и вам нужен другой паттерн (Strategy/Bridge/DI)? ⭐⭐⭐
- Опишите компромисс: «больше интерфейсов и классов» vs «гарантированная совместимость».
  Как бы вы аргументировали решение команде? ⭐⭐⭐
- Как обеспечить, чтобы продукты одного семейства не создавали напрямую продукты другого семейства? ⭐⭐⭐
- Как связать абстрактную фабрику с фабричным методом в одном решении? ⭐⭐

### Паттерн проектирования "Фабричный метод"

- Сформулируйте идею паттерна «Фабричный метод» своими словами и объясните, где в PizzaStore он проявляется. ⭐
- Почему фабричный метод часто сочетается с шаблонным методом? Что фиксируется, а что вариативно? ⭐⭐
- Какие зависимости убирает фабричный метод по сравнению с прямым созданием (`new`/`make_unique`) в клиенте? ⭐⭐
- Как фабричный метод помогает соблюдать OCP на примере расширения ассортимента пиццы? ⭐⭐
- В чём различие между «простая фабрика» и «фабричный метод» на уровне расширяемости и наследования? ⭐⭐
- Опишите параметризованный фабричный метод и его типичные проблемы. Как их лечить? ⭐⭐
- Опишите непараметризованный фабричный метод. В каких сценариях он предпочтительнее? ⭐⭐
- Почему «параллельные иерархии классов» считаются недостатком FactoryMethod и когда это оправдано? ⭐⭐⭐
- Как избежать комбинаторного взрыва, если фабричных методов несколько и продуктов много? ⭐⭐⭐
- Какие есть способы ограничить переопределение алгоритма конструирования объекта в базовом классе? ⭐⭐
- Объясните, почему ошибка типа «забыли вызвать `Pizza::Cut()`» — системная проблема дизайна,
  а не баг конкретного разработчика. ⭐⭐
- Какая часть кода должна оставаться в базовом классе Creator, а какая — в подклассах? Назовите критерии. ⭐⭐
- Как фабричный метод соотносится с DIP: кто от кого должен зависеть? ⭐⭐
- Почему использование строковых параметров (`type == "cheese"`) — риск? Предложите улучшение API. ⭐⭐
- Какие варианты обработки ошибок создания продукта вы предложите (исключения/Optional/Result)
  и как это влияет на дизайн Creator? ⭐⭐⭐
- Как тестировать базовый алгоритм Creator независимо от конкретных продуктов? ⭐⭐
- Как тестировать конкретный подкласс Creator так, чтобы не дублировать тесты базового алгоритма? ⭐⭐⭐
- Когда FM превращается в анти-паттерн: «переабстракция на вырост»? Приведите признаки. ⭐⭐
- Как выглядит «протекающая абстракция» в FM и как её исправить (когда клиент всё равно знает ConcreteProduct)? ⭐⭐⭐
- В чём смысл требования: «Creator не должен делать предположений о конкретном типе продукта»?
  Как это нарушается на практике? ⭐⭐⭐
- Как бы вы рефакторили код DependentPizzaStore, чтобы применить фабричный метод и уменьшить зависимости? ⭐⭐
- Что изменится в проекте при добавлении новой пиццы и нового региона при использовании FM? Сравните с подходом без FM. ⭐⭐⭐
- Как выбрать между FM и Strategy для задачи «выбор типа создаваемого объекта во время выполнения»? ⭐⭐⭐
- Какие компромиссы возникают при попытке сделать фабричный метод статическим? ⭐⭐
- Как фабричный метод влияет на способность кэшировать/переиспользовать продукты или их части? ⭐⭐⭐
- В C++: какие вопросы владения ресурсами (unique_ptr/shared_ptr) особенно важны при реализации FM? ⭐⭐
- Как обеспечить, что разные подклассы Creator не нарушат инварианты продукта (например, обязательные шаги подготовки)? ⭐⭐⭐
- Приведите пример, где FM лучше заменить на Abstract Factory, и объясните, почему FM не справляется. ⭐⭐⭐

### Паттерны проектирования "Команда" и "Хранитель"

- Объясните, какую архитектурную проблему решает паттерн **Command** и почему прямой вызов методов получателя из UI считается плохим решением. ⭐
- В чём различие ролей **Client**, **Invoker**, **Command**, **Receiver**? Приведите пример для каждого участника из системы “меню → робот”. ⭐
- Почему **инициатор (Invoker)** не должен создавать команды? Какие зависимости возникнут, если он будет знать конкретные классы команд? ⭐⭐
- Какие преимущества даёт то, что запрос представлен объектом (Command), а не вызовом метода? Назовите минимум 3 практических эффекта. ⭐
- Что именно должно храниться внутри объекта команды: получатель, параметры, логика, состояние? Обоснуйте распределение ответственности. ⭐⭐
- Объясните, что означает “ослабление связности” в контексте Command. Какая связность уменьшается и какие зависимости остаются? ⭐⭐
- Как паттерн Command помогает реализовать **конфигурирование действий** (например, связывание фраз с командами в меню)? ⭐
- Как бы вы расширили пример с роботом, чтобы добавить команду “идти 10 секунд”, не меняя код меню? Какие параметры и где вы бы хранили? ⭐⭐
- В каких случаях команда может быть реализована не классом, а **функциональным объектом** (`std::function`, лямбда)? Какие плюсы и минусы у такого подхода? ⭐⭐
- Как изменится тестируемость системы при переходе от прямых вызовов к Command? Какие части станет легче мокать и проверять? ⭐⭐
- Опишите архитектуру **Undo/Redo** на базе Command: какие структуры данных нужны и какие операции выполняются при Undo и Redo. ⭐⭐
- Почему не каждая операция естественно обратима? Приведите примеры команд, для которых сложно или дорого реализовать `Unexecute()`. ⭐⭐
- Объясните, как реализовать **макрокоманду** с возможностью отката изменений? ⭐⭐
- Что такое **макрокоманда** и какие паттерны в ней сочетаются? ⭐⭐
- Как бы вы реализовали макрокоманду так, чтобы при ошибке в середине выполнения система оставалась в консистентном состоянии? ⭐⭐⭐
- В чём проблема “избыточной истории изменений” в редакторах и почему она ухудшает UX Undo/Redo? ⭐
- Объясните идею **склеивания (coalescing)** соседних команд редактирования. По каким признакам можно понять, что команды нужно объединить? ⭐⭐
- Чем отличаются стратегии `AddEdit()` и `ReplaceEdit()` при работе с историей изменений в примере из лекции?
  В каких случаях полезна каждая из них? ⭐⭐
- В примере `EditText::ReplaceEditImpl()` используется сравнение `otherEditText->m_newText == m_oldText`.
  Почему это важная проверка и какую семантику она выражает? ⭐⭐⭐
- Какие риски появляются при “умных командах”, которые пытаются оптимизировать историю (например, склеивание)?
  Как это может повлиять на корректность Undo/Redo? ⭐⭐⭐
- Опишите две крайности “интеллектуальности команд” и объясните, почему они вредны с точки зрения принципов ООП и SOLID. ⭐⭐
- Где должна находиться бизнес-логика: в команде или в получателе? Приведите критерии принятия решения. ⭐⭐
- Какие дополнительные возможности появляются, если команды можно **сериализовать и десериализовать**?
  Какие ограничения это накладывает на дизайн команд? ⭐⭐⭐
- Как реализовать асинхронное выполнение команд (очередь задач, выполнение в другом потоке)? ⭐⭐⭐
- Чем Command-подход к Undo/Redo отличается от подхода “сохранить снимок состояния”? В каких случаях Command выгоднее? ⭐⭐
- Сформулируйте идею паттерна **Memento** и объясните, как он сохраняет инкапсуляцию. ⭐⭐
- Опишите роли **Originator**, **Memento**, **Caretaker** и их взаимодействие. Кто имеет право читать/изменять состояние? ⭐⭐
- Почему “классическая версия” Memento может потенциально нарушать инкапсуляцию, и как “альтернативная версия” решает эту проблему? ⭐⭐⭐
- В каких случаях Memento может быть слишком дорогим по памяти? Какие оптимизации можно применить? ⭐⭐⭐
- Спроектируйте систему Undo/Redo для редактора, где часть операций реализована через Command, а часть — через Memento.
  Как бы вы комбинировали их и почему? ⭐⭐⭐

### Паттерн проектирования "Адаптер"

Конечно! Ниже — **30 открытых экзаменационных вопросов** по паттерну **«Адаптер»**, которые проверяют не только знание определения, но и **глубину понимания ООП, проектирования, зависимостей, архитектурных компромиссов**, а также связь с материалом твоих слайдов (утки/индюшки, изменение интерфейса библиотеки, препятствия, сравнение с декоратором, функциональный адаптер, ListView datasource и т.д.).

---

## 30 экзаменационных вопросов по паттерну «Адаптер»

- Объясните паттерн «Адаптер» своими словами и приведите **пример из промышленной разработки**, где он является наиболее уместным решением. ⭐
- Почему изменение интерфейса внешней библиотеки часто приводит к «поломке» системы? Какие свойства архитектуры делают систему особенно уязвимой к таким изменениям? ⭐⭐
- В каких ситуациях **переписывание клиентского кода** является плохой альтернативой адаптеру? Оцените это с точки зрения стоимости сопровождения и рисков. ⭐⭐
- Опишите роли **Client / Target / Adapter / Adaptee** и объясните, какие зависимости между ними допустимы, а какие являются архитектурной ошибкой. ⭐⭐
- Почему клиент «не должен знать про наличие адаптера»? Какие проблемы возникнут, если клиент начнёт зависеть от конкретного адаптера? ⭐⭐
- Рассмотрите пример «утки и индюшки». Какие именно несовместимости интерфейсов присутствуют в этом примере и как адаптер их устраняет? ⭐
- В примере с утками метод `Fly()` адаптера вызывает `Fly()` индюшки 5 раз. Почему это важно с точки зрения **семантической адаптации**, а не только совпадения сигнатур? ⭐⭐
- Что произойдёт, если адаптер будет реализован формально (методы совпадают), но **семантика поведения** не соответствует ожиданиям клиента? Приведите пример ошибки проектирования. ⭐⭐
- Объясните разницу между **объектным адаптером** и **классовым адаптером**. Когда вы выберете один подход вместо другого? ⭐⭐
- Какой адаптер обычно считается более гибким: объектный или классовый? Как это связано с принципами ООП? ⭐⭐
- Какие преимущества даёт классовый адаптер в C++ и какие ограничения он накладывает на архитектуру системы? ⭐⭐
- В каких случаях множественное наследование в классовом адаптере может стать источником проблем?
  Какие это проблемы (не только технические, но и архитектурные)? ⭐⭐⭐
- Рассмотрите слайд про «объём работы»: почему сложность адаптера пропорциональна размеру Target-интерфейса?
  Какие практики помогают уменьшить эту стоимость? ⭐⭐
- Что такое «замаскированные зависимости от конкретных классов» и почему они мешают внедрению адаптера?
  Приведите пример кода или ситуации. ⭐⭐⭐
- Почему адаптер легче внедрять в код, который зависит от интерфейсов? Как это связано с DIP (Dependency Inversion Principle)? ⭐⭐
- Можно ли считать адаптер нарушением SRP (Single Responsibility Principle)?
  Аргументируйте ответ и поясните, где проходит граница ответственности адаптера. ⭐⭐⭐
- Как адаптер помогает реализовать принцип Open/Closed? Какие изменения в системе должны происходить при смене внешнего API? ⭐⭐
- Чем адаптер отличается от фасада (Facade) по цели и эффекту на архитектуру? Приведите пример, где один паттерн подходит, а другой — нет. ⭐⭐⭐
- Чем адаптер отличается от прокси (Proxy)? В каких случаях прокси может выглядеть как адаптер и почему важно различать их намерение? ⭐⭐⭐
- Чем адаптер отличается от декоратора? Объясните разницу на уровне **контракта** и **намерения**.
  Приведите пример, где путаница приведёт к плохому дизайну. ⭐⭐⭐
- В каких ситуациях адаптер может «прятать» проблемы дизайна и откладывать рефакторинг, вместо того чтобы улучшать систему? ⭐⭐⭐
- Допустим, у вас есть несколько внешних библиотек с разными интерфейсами, но одинаковым смыслом.
  Как бы вы спроектировали систему адаптеров, чтобы клиентский код не зависел от конкретной библиотеки? ⭐⭐⭐
- Что делать, если адаптируемый интерфейс часто меняется (частые breaking changes)?
  Как организовать адаптеры и тесты, чтобы изменения локализовывались? ⭐⭐⭐
- Какие виды тестов наиболее важны для адаптера: модульные, контрактные, интеграционные?
  Что именно должен гарантировать тест адаптера? ⭐⭐
- Рассмотрите пример с ListView и `IListViewDataSource`. Почему это пример адаптера, даже если он выглядит как «просто интерфейс»?
  Где здесь Target и Adaptee? ⭐⭐⭐
- Почему вариант «передавать массив IListItemView» (готовые визуальные элементы) считается плохим решением?
  Объясните с точки зрения производительности, архитектуры и ответственности. ⭐⭐⭐
- Как адаптер в ListView помогает реализовать ленивое создание элементов (on-demand)?
  Какие преимущества это даёт? ⭐⭐
- Приведите пример адаптера для подключения клиента к нескольким TTS-сервисам.
  Какие интерфейсы вы бы сделали целевыми, и какие проблемы интеграции адаптер должен скрывать? ⭐⭐⭐
- Что такое **функциональный адаптер** (адаптация функции к другой сигнатуре/контракту)?
  Приведите пример преобразования входных данных и объясните, почему это тоже «Адаптер». ⭐⭐
- Приведите пример функционального адаптера, который превращает синхронную функцию в асинхронную (sync → async).
  Какие ограничения и гарантии должен соблюдать такой адаптер? ⭐⭐⭐
- Напишите адаптер, адаптирующий объекты `adaptee` к интерфейсам `target`. См. диаграмму классов:

  ```mermaid
  classDiagram
    namespace target {
      class IShape {
        <<interface>>
        GetStyle() IStyle&
      }

      class IStyle {
        <<interface>>
        GetColor() uint32
      }
    }

    namespace adaptee {
      class Shape {
        m_style: Style
        GetStyle() Style&
      }
      class Style {
        m_color: Color
        GetColor() Color
      }
      class Color {
        <<struct>>
        r: byte
        g: byte
        b: byte
        a: byte
      }
    }
    class Client {
    }

    IShape ..> IStyle
    Shape *-- Style
    Style *-- Color
    Client ..> IShape
    Client ..> IStyle
  ```

### Паттерн проектирования "Шаблонный метод"

- Объясните суть паттерна «Шаблонный метод» и сформулируйте, какой именно тип повторного использования он даёт. ⭐
- Почему «дублирование кода» часто является сигналом к архитектурным изменениям?
  Какие виды дублирования особенно опасны в OOP? ⭐⭐
- В «тривиальном решении» (когда `PrepareRecipe()` виртуальный/абстрактный и реализуется в каждом подклассе) какие проблемы появляются при изменении порядка шагов алгоритма?
  Объясните на уровне сопровождения и рисков регрессий. ⭐⭐
- Дайте определение «скелета алгоритма» в Template Method.
  Как отличить «скелет» от «деталей реализации» в реальном коде? ⭐⭐
- Почему в классическом Template Method базовый метод-шаблон (`PrepareRecipe`) часто делают **невиртуальным**? ⭐⭐
- Объясните разницу между **абстрактными шагами** (pure virtual) и **hooks** (виртуальные с реализацией по умолчанию).
  Приведите пример, когда hook лучше абстрактного метода. ⭐⭐
- Придумайте 2–3 разных типа hook’ов в шаблонном методе и поясните их влияние на расширяемость и читаемость. ⭐⭐
- В примере с `CustomerWantsCondiments()` какие риски вносит интерактивный ввод/IO в hook?
  Как бы вы тестировали такой код? ⭐⭐
- Как Template Method связан с Голливудским принципом («принцип инверсии управления»)?
  Опишите различие между *направлением зависимостей* и *направлением потока управления*. ⭐⭐
- Сравните DIP и Голливудский принцип: почему можно соблюдать один и нарушать другой? Приведите пример. ⭐⭐⭐
- Какие антипаттерны/запахи кода могут возникнуть при чрезмерном использовании Template Method? Как их распознать? ⭐⭐⭐
- Какие требования к контракту (pre/post conditions, инварианты) особенно важны в Template Method?
  Где их лучше фиксировать: в базовом методе или в шагах? Почему? ⭐⭐⭐
- Что такое идиома NVI (Non-Virtual Interface) и чем она отличается по фокусу от Template Method?
  В каких случаях NVI предпочтительнее? ⭐⭐
- Разберите пример `Document::Save()` (NVI): какие элементы “политики” централизованы в невиртуальном методе и почему это полезно для качества системы? ⭐⭐
- Почему сочетание `virtual` + default arguments в C++ опасно?
  Объясните механизм привязки значений по умолчанию и покажите, как NVI решает проблему. ⭐⭐⭐
- Какие шаги в Template Method стоит делать `private`, какие `protected`, а какие `public`?
  Обоснуйте с точки зрения инкапсуляции и защиты контракта. ⭐⭐
- Опишите типичные ошибки проектирования Template Method в C++: вызов виртуальных методов из конструктора/деструктора, “обходные” публичные виртуальные методы, нарушение инвариантов.
  Почему они опасны? ⭐⭐⭐
- Допустим, в шаблонном методе есть шаг, который должен быть выполнен *ровно один раз* (идемпотентность/инициализация).
  Где лучше хранить состояние и как избежать “частично инициализированного” объекта? ⭐⭐⭐
- Придумайте пример, где Template Method конфликтует с LSP (принцип подстановки Лисков).
  Что именно должен “сломать” подкласс, чтобы нарушить LSP? ⭐⭐⭐
- Как бы вы документировали точки расширения Template Method, чтобы избежать “магии фреймворка” и скрытых зависимостей порядка вызовов? ⭐⭐
- В каких ситуациях Template Method лучше заменить на Strategy? Сформулируйте критерии выбора. ⭐⭐
- Как Template Method соотносится с Factory Method? Приведите сценарий, когда Template Method вызывает фабричный метод на одном из шагов. ⭐⭐
- В примере “напитков” добавьте шаг “подогреть чашку” или “проверить наличие ингредиентов”. Куда вы его добавите и почему? ⭐⭐
- Опишите compile-time Template Method (CRTP): как переносится диспетчеризация из рантайма в компилятор?
  Какие требования предъявляются к Derived? ⭐⭐
- Какие ограничения CRTP-варианта критичны для архитектуры? Как бы вы смягчали эти ограничения? ⭐⭐⭐
- Почему “нестатические методы наследника нельзя вызывать из конструктора/деструктора родителя” особенно важно в CRTP-варианте?
  Приведите пример бага и способ избежать. ⭐⭐⭐
- Спроектируйте Template Method для Undo/Redo (команды): какие шаги должны быть инвариантными, а какие — вариативными? ⭐⭐⭐
- Приведите пример Template Method в UI/веб-фреймворке (pipeline обработки события/запроса).
  Какие hooks там обычно предоставляют, и какие риски создаёт неправильное использование hooks? ⭐⭐⭐
- Представьте, что вам нужно обеспечить единые политики для набора операций, где часть шагов вариативна.
  Как бы вы совместили Template Method и NVI так, чтобы подклассы не могли “обойти” политику? ⭐⭐⭐

### Паттерн проектирования "Итератор"

- Объясните, какую проблему решает паттерн «Итератор» и почему он относится к поведенческим паттернам. ⭐
- Почему перебор элементов через индексы (`GetBookAtIndex(i)`) может быть плохим решением? ⭐
- Какие недостатки появляются в коде, когда клиент напрямую зависит от типа контейнера (`deque`, `unordered_map` и т.д.)? ⭐⭐
- В чём заключается «раскрытие внутреннего представления коллекции» и почему это вредно? ⭐⭐
- Как новые требования ломают исходную архитектуру библиотеки? ⭐⭐
- Почему добавление индексов (`m_authorBooks`) может привести к дублированию кода обхода коллекции? ⭐⭐
- В чём разница между «данными» и «представлением данных» в контексте примера Library? ⭐⭐
- Какие принципы SOLID нарушаются в примере до введения итератора? Обоснуйте. ⭐⭐⭐
- Как паттерн «Итератор» помогает следовать принципу OCP (Open/Closed Principle)? ⭐⭐
- Почему «универсальная функция PrintBooks» — хороший критерий успешного внедрения итератора? ⭐⭐
- Опишите минимальный набор операций, который должен поддерживать итератор для корректного последовательного обхода. ⭐
- Почему в интерфейсе итератора разделяют методы `HasBook()` и `GetBook()` вместо одного метода “GetNext”? ⭐⭐
- Какие ошибки проектирования могут возникнуть, если `GetBook()` вызывают без проверки `HasBook()`? ⭐⭐
- Какие варианты поведения итератора возможны при выходе за границы коллекции? Как выбрать? ⭐⭐⭐
- Как вы объясните ответственность коллекции и ответственность итератора в паттерне? ⭐⭐
- Сравните внешний и внутренний итератор: где какой удобнее, и какие компромиссы по гибкости/контролю? ⭐⭐
- Приведите пример задачи, которую сложно реализовать внутренним итератором, но легко внешним. ⭐⭐
- Можно ли сказать, что range-based for в C++ использует итератор? Объясните, что за интерфейс там требуется. ⭐⭐
- Как паттерн «Итератор» связан с инкапсуляцией и сокрытием реализации? ⭐⭐
- В примере `BookByTitleIterator` хранит итератор по `unordered_map<string, const Book*>`.
  Какие риски появляются из-за хранения указателей? ⭐⭐⭐
- Как обеспечить корректность итераторов, если коллекция может изменяться во время обхода? Какие стратегии существуют? ⭐⭐⭐
- Почему в примере итераторы возвращаются через `std::unique_ptr<IBookIterator>`? Какие плюсы и минусы такого решения? ⭐⭐
- Как бы вы изменили дизайн, чтобы избежать heap-аллокаций при создании итератора (но сохранить полиморфизм)? ⭐⭐⭐
- Какие альтернативы виртуальному интерфейсу итератора существуют в C++ (шаблоны, концепты, type erasure)? Сравните. ⭐⭐⭐
- Зачем добавляют метод `Clone()` в интерфейс итератора и с каким паттерном он связан? ⭐⭐
- Почему копирование итератора нельзя корректно реализовать обычным копирующим конструктором базового интерфейса? ⭐⭐⭐
- В чём смысл класса-обёртки `BookIterator` и какие задачи он решает для клиента? ⭐⭐
- Какие инварианты и гарантии вы бы сформулировали для корректного итератора (валидность, неизменность позиции, исключения)? ⭐⭐⭐
- Спроектируйте расширение примера: итератор, который обходит книги только за заданный диапазон лет или только по префиксу названия.
  Где должна быть логика фильтрации — в коллекции, в итераторе или в отдельном объекте? Обоснуйте. ⭐⭐⭐

### Паттерн проектирования "Компоновщик"

- Дайте определение паттерна «Компоновщик» и объясните, какую проблему проектирования он решает на практике. ⭐
- В чём состоит ключевая идея «прозрачности» (transparency) в Composite и почему она важна для клиентского кода? ⭐⭐
- Объясните роли **Component / Leaf / Composite** и приведите пример соответствия этим ролям в задаче «слайд–фигуры–группы». ⭐
- Почему древовидная структура естественна для моделирования отношений «часть–целое»?
  Приведите 2–3 примера из реальных систем. ⭐
- Какие инварианты должны выполняться в корректной реализации Composite-дерева? ⭐⭐
- Опишите, как будет выглядеть интерфейс `IDrawable`/`IShape`, чтобы и листья, и группы можно было рисовать одинаково.
  Какие операции туда логично включать? ⭐⭐
- Что произойдёт архитектурно, если добавить группировку фигур “в лоб”, без Composite?
  Какие проблемы возникнут? ⭐⭐
- В примере со слайдами: почему удобно, что `Slide` тоже реализует `IDrawable`? Как это влияет на дизайн? ⭐⭐
- Как вы реализуете `GroupShape::Draw(canvas)` так, чтобы поведение соответствовало «группа ведёт себя как одна фигура»? ⭐
- Опишите корректную реализацию `GetFrame()` для группы фигур: какие случаи нужно учесть и почему пустая группа — отдельная проблема? ⭐⭐
- Как реализовать `SetFrame()` для группы так, чтобы изменения размеров/положения группы пропорционально изменяли детей?
  Какие ошибки и трудности возможны? ⭐⭐⭐
- Что такое Z-order и как порядок потомков в Composite влияет на отрисовку и пользовательские ожидания? ⭐⭐
- Какие варианты хранения детей вы бы выбрали в C++: `unique_ptr`, `shared_ptr`,
  ссылки/сырой указатель? Обоснуйте выбор для фигур/групп. ⭐⭐
- Объясните разницу между **композицией и агрегацией** в контексте групп фигур и приведите пример, когда нужна агрегация. ⭐⭐
- Зачем может понадобиться ссылка на родителя в узлах Composite? Какие операции она упрощает? ⭐⭐
- Какие риски возникают при хранении ссылок на родителей? Как обеспечить инвариант «если A.parent = B, то B содержит A»? ⭐⭐⭐
- Можно ли разрешить совместное использование компонентов (один дочерний объект у двух родителей)?
  Какие проблемы это создаёт для определения родителя, удаления и трансформаций? ⭐⭐⭐
- Объясните дилемму: где размещать операции `Add/Remove/GetChild` — в `Component` или только в `Composite`?
  Какие плюсы/минусы у каждого варианта? ⭐⭐⭐
- Опишите компромисс через `GetComposite()` (возвращает `nullptr` для листьев).
  В чём частичная потеря прозрачности и как клиент должен действовать? ⭐⭐
- Как лучше реализовать “неразумные” операции для листьев (например, `Add` у Leaf): пустая реализация, исключение, код ошибки?
  Обоснуйте. ⭐⭐
- Какие типичные логические ошибки возможны при построении структуры Composite и как их предотвращать? ⭐⭐
- Как бы вы реализовали проверку на циклы при `Add`? Какие компромиссы по производительности и удобству появляются? ⭐⭐⭐
- Зачем Composite может кешировать вычисления (например, bounding box группы)? Как организовать инвалидирование кэша при изменении детей? ⭐⭐⭐
- Опишите схему уведомлений “child changed → parent invalidates cache → уведомляет своего parent”. Какие варианты реализации? ⭐⭐⭐
- Почему часто Composite сочетают с Visitor?
  Приведите пример операции, которую лучше вынести в Visitor, а не добавлять в классы фигур/узлов. ⭐⭐
- Объясните связь Composite и Iterator: какие задачи решает внешний итератор по дереву,
  и почему это лучше, чем “ручная рекурсия” в клиентском коде? ⭐⭐
- Как реализовать обход дерева: DFS/BFS, “только листья”, “только видимые” — и где в дизайне лучше задавать стратегию обхода? ⭐⭐⭐
- Можно ли реализовать Composite без наследования через `std::variant`/`std::visit`?
  Какие преимущества и ограничения такого подхода по сравнению с виртуальными методами? ⭐⭐⭐
- Опишите функциональный вариант “Компоновщика” для команд: простые функции + макро-функция, работающая с контекстом (мутабельным или иммутабельным). Какие плюсы/минусы и где это применимо? ⭐⭐⭐

### Паттерн проектирования "Состояние"

- Что именно считается «внутренним состоянием» объекта в паттерне State и чем оно отличается от обычных полей класса? ⭐
- Почему реализация автомата через switch(m_state) быстро деградирует при добавлении новых состояний и действий?
  Приведи конкретные причины. ⭐
- Какие изменения в коде автомата придётся сделать, если добавить новое состояние (например, “WinnerState” — выдаёт 2 жвачки за одну монету) в варианте со switch? ⭐⭐
- В чём заключается нарушение принципа Open/Closed в реализации с enum State и switch?
  Почему это опасно на практике? ⭐⭐
- Опиши роль Контекста в паттерне State и перечисли, за что он должен отвечать, а за что — нет. ⭐⭐
- Как понять, какие фрагменты поведения нужно переносить из Контекста в состояния, а какие оставить в Контексте? ⭐⭐
- Почему в паттерне State клиент обычно не должен напрямую менять текущее состояние объекта?
  Какие проблемы это может вызвать? ⭐⭐
- Объясни разницу между «объект меняет поведение» и «объект меняет класс» в терминах паттерна State. Почему говорят, что “выглядит так, будто меняет класс”? ⭐⭐
- В примере автомата почему метод TurnCrank() вызывает и TurnCrank(), и Dispense() у состояния?
  Какие плюсы и минусы у такого протокола вызовов? ⭐⭐⭐
- Какие риски появляются, если позволить состояниям напрямую менять поля Контекста (например, m_count), минуя интерфейс IGumballMachine? ⭐⭐
- Зачем вводить интерфейс IGumballMachine для состояний, если у нас уже есть класс GumballMachine? ⭐⭐
- Почему в примере класс GumballMachine приватно наследуется от IGumballMachine? Какой архитектурный смысл в этом решении? ⭐⭐
- Какие альтернативы приватному наследованию подходят для языков, где оно отсутствует (Java/C#)?
  Как бы вы это спроектировали? ⭐⭐
- Какие именно зависимости возникают между классами состояний, если состояния будут создавать друг друга напрямую (new HasQuarterState(...)) или ссылаться друг на друга? ⭐⭐⭐
- Объясни два подхода: кто выбирает следующее состояние — Контекст или сами состояния.
  Когда предпочтителен каждый вариант? ⭐⭐⭐
- Какой вариант управления переходами лучше защищает от изменений: закрывать Контекст или закрывать состояния
  Обоснуйте через OCP. ⭐⭐⭐
- Как бы вы реализовали логирование/трассировку переходов между состояниями так, чтобы не нарушить SRP и не размазать std::cout по всем классам? ⭐⭐⭐
- Если в системе нужно “откатить” состояние назад (undo), как это влияет на архитектуру State?
  Какие паттерны можно комбинировать? ⭐⭐⭐
- В чём сходство диаграмм State и Strategy и почему при этом смысл у них принципиально разный? ⭐⭐
- Приведите пример системы, где ошибочно применили Strategy вместо State (или наоборот), и объясните, какие симптомы покажут неправильный выбор. ⭐⭐⭐
- Какие признаки в коде указывают, что пора переходить от if/switch к паттерну State? ⭐⭐
- В каких случаях паттерн State будет избыточным усложнением? Как бы вы аргументировали отказ от него? ⭐⭐
- Что произойдёт с тестируемостью системы после внедрения State? Какие тесты станет проще писать, а какие — сложнее? ⭐⭐⭐
- Как лучше организовать создание объектов состояний: (а) заранее и навсегда или (б) по требованию? Какие критерии выбора вы бы использовали? ⭐⭐
- Почему “совместное использование объектов состояний разными контекстами” возможно только при условии, что состояния stateless? ⭐⭐⭐
- Можно ли делать состояния stateful (хранящими данные)? Когда это оправдано, и какие новые риски появляются? ⭐⭐⭐
- State — интерфейс или абстрактный класс? В каких случаях ты выберешь каждый вариант и почему? ⭐⭐
- Спроектируй расширение автомата: добавь состояние “ServiceMode” (обслуживание),
  в котором клиент не может покупать, но техник может пополнять жвачки.
  Какие классы/методы появятся, какие переходы изменятся, и как сохранить чистую архитектуру? ⭐⭐⭐

### Паттерн проектирования "Заместитель"

- Объясните паттерн Proxy своими словами: какую проблему он решает? ⭐
- Какие признаки в архитектуре подсказывают, что нужен Proxy, а не просто «вынести код в отдельный класс»? ⭐⭐
- Опишите минимальную структуру Proxy (Subject / RealSubject / Proxy). Какие зависимости допустимы, а какие приведут к «протеканию абстракции»? ⭐⭐
- Почему важно, чтобы клиент «не знал и не обязан знать», что работает с Proxy? Какие последствия возникают, если клиент начинает делать проверки вида `if (obj is Proxy)`? ⭐⭐
- Чем Proxy принципиально отличается от Adapter? Приведите пример ситуации, где визуально структуры похожи, но намерение разное. ⭐⭐
- Чем Proxy принципиально отличается от Decorator? Сформулируйте критерий, по которому вы точно определите выбор на практике. ⭐⭐
- Кэширование можно реализовать и как Proxy, и как Decorator. Опишите два варианта постановки задачи, которые приведут к разным решениям, и как это отразится на публичном API. ⭐⭐⭐
- Объясните Virtual Proxy: что именно считается «дорогим» в создании объекта, и как Proxy помогает уменьшить стоимость старта системы? ⭐
- В примере с `ImageProxy`: почему Proxy хранит «примерный размер» (`m_size`) до загрузки реального изображения? Какие компромиссы точности/удобства тут заложены? ⭐⭐
- Как бы вы спроектировали Virtual Proxy, если реальный объект может **не только долго создаваться**,
  но и часто **падать при загрузке**? Какие состояния и переходы должны быть у Proxy? ⭐⭐
- В `ImageProxy::Impl::Draw()` используется `weak_from_this()` и `lock()`.
  Объясните, какую проблему это решает в асинхронном callback, и что может пойти не так без этого. ⭐⭐⭐
- Как реализовать «частичную функциональность» в Virtual Proxy? Как при этом не сломать LSP? ⭐⭐⭐
- Что будет считаться «утечкой деталей реализации» Virtual Proxy в клиентский код? Приведите 2–3 примера таких утечек. ⭐⭐
- Объясните Remote Proxy: почему он считается разновидностью Proxy, а не просто сетевым клиентом?
  Какие свойства делают удалённость прозрачной? ⭐⭐
- В примере с утками: какие обязанности у DuckProxy, а какие — у DuckStub? Почему важно разделять эти роли? ⭐⭐
- Опишите полный путь вызова `duck.Fly(...)` в Remote Proxy (по шагам, включая сериализацию/десериализацию, обработку ошибок). ⭐⭐
- В `DuckStub::HandleFly` параметры парсятся из строки. Какие проблемы появятся при усложнении протокола (версии, бинарные данные, совместимость)? Как бы вы это переработали? ⭐⭐⭐
- Как корректно моделировать и обрабатывать ошибки в Remote Proxy: таймауты, сетевые сбои, частичные отказы?
  Что должен «видеть» клиент: исключения, коды ошибок, ретраи? ⭐⭐⭐
- Что такое «семантическая прозрачность» Remote Proxy: в каких случаях невозможно сделать удалённый вызов полностью эквивалентным локальному? ⭐⭐⭐
- Как влияет Remote Proxy на контракт методов (идемпотентность, побочные эффекты, повторные вызовы при ретраях)? 
  Приведите пример, где наивный ретрай ломает бизнес-логику. ⭐⭐⭐
- Расскажите про Protection Proxy: что именно он должен проверять,
  и почему перенос этих проверок в RealSubject часто ухудшает дизайн? ⭐⭐
- В примере `DocumentProtectionProxy`: почему чтение разрешено всем, а редактирование/удаление — нет.
  Как бы вы расширили архитектуру, не раздувая Proxy условными операторами? ⭐⭐⭐
- Что лучше сделать при запрете операции в Protection Proxy: молча «return», логировать,
  бросать исключение, возвращать статус? От чего зависит выбор? ⭐⭐
- Опишите угрозы, которые Protection Proxy **не** решает.
  Какие архитектурные меры нужны, чтобы прокси действительно защищал? ⭐⭐⭐
- Что такое Smart Proxy, и чем он отличается от «просто логирования»?
  Какие признаки указывают, что вы строите именно Smart Proxy? ⭐⭐
- Объясните идею Copy-on-Write как Smart Proxy: какие инварианты должны соблюдаться, чтобы копия создавалась только при модификации? ⭐⭐
- В примере `CoW::Write()` (возвращающем ссылку) показана ошибка, когда сохраняют ссылку и меняют данные после копирования.
  Объясните, почему это ломает CoW, и как вспомогательный тип `WriteProxy` предотвращает проблему на уровне типов. ⭐⭐⭐

### Паттерн проектирования "Посетитель"

- Объясните идею паттерна Visitor своими словами: какую проблему он решает и почему она возникает именно в ООП-системах? ⭐
- В примере с фигурами: почему требование “легко менять формат вывода (Plain/XML/Binary)” приводит к необходимости пересмотреть дизайн? ⭐
- Какие недостатки “классического решения” с методами вроде `ToString()`, `ToXml()`, `ToBinaryArray()` проявляются при росте проекта? ⭐⭐
- Как связаны Visitor и принцип **Open/Closed (OCP)**? В каком смысле Visitor “открывает” систему для расширения? ⭐⭐
- Опишите роли в паттерне Visitor: **Visitor**, **ConcreteVisitor**, **Element**, **ConcreteElement**, **ObjectStructure**.
  Что делает каждая роль? ⭐⭐
- Что именно происходит во время вызова `shape.Accept(visitor)` на уровне диспетчеризации методов?
  Почему это называют “двойной диспетчеризацией”? ⭐⭐⭐
- Почему в Visitor метод `Accept()` обычно находится в базовом классе элементов (`Shape`),
  а методы `Visit(...)` — в посетителе? Какое это даёт разделение ответственности? ⭐⭐
- В примере со слайдами `StreamOutputVisitor` хранит `m_indent`. Какие преимущества это даёт? ⭐⭐
- Объясните, почему поддержка **pretty-print** в “классическом подходе” начинает выглядеть как “протаскивание контекста” через API.
  Какие проблемы это вызывает? ⭐⭐
- Как Visitor помогает объединять “родственные операции”?
  Приведите пример набора операций, которые логично держать в одном посетителе. ⭐
- В каких случаях Visitor становится антипаттерном или неоправданным усложнением?
  Назовите критерии, по которым вы бы отказались от Visitor. ⭐⭐
- Почему Visitor особенно хорошо подходит, когда
  “классы структуры меняются редко, а операции добавляются часто”? Раскройте этот компромисс. ⭐⭐
- Какие проблемы появляются, если структура классов (ConcreteElement) меняется часто,
  а посетителей много? Почему это болезненно? ⭐⭐
- Объясните недостаток Visitor “затрудняется добавление новых ConcreteElement”.
  Что именно приходится менять и почему это нарушает масштабируемость? ⭐⭐
- Как Visitor может привести к нарушению инкапсуляции?
  Какие “публичные геттеры” приходится добавлять и почему это может быть плохо? ⭐⭐⭐
- В примере `ShapeGroup` содержит коллекцию `Shapes`. Как Visitor корректно обходит дерево объектов и почему именно `ShapeGroup::Visit()` обычно рекурсивен? ⭐⭐
- В чём разница между Visitor для “плоской коллекции” и Visitor для “иерархии/дерева” объектов?
  Какие дополнительные вопросы появляются во втором случае? ⭐⭐
- Как бы вы реализовали несколько форматов сериализации (XML, JSON, Binary) через Visitor так, чтобы не дублировать общий код (например, обход дерева)? ⭐⭐⭐
- Объясните, что такое **циклическая зависимость** между Visitor и ConcreteElement в классическом Visitor.
  В чём её практический вред? ⭐⭐⭐
- Как работает **Acyclic Visitor** (ациклический посетитель) и какую проблему он решает по сравнению с классическим Visitor? ⭐⭐⭐
- Почему в Acyclic Visitor вводят пустой базовый интерфейс `VisitorBase`? Какую архитектурную роль он играет? ⭐⭐
- В Acyclic Visitor элементы используют `dynamic_cast` для определения, умеет ли посетитель их обрабатывать. Какие плюсы и минусы такого решения? ⭐⭐⭐
- Что произойдёт, если посетитель не поддерживает конкретный тип элемента в Acyclic Visitor? Как это влияет на корректность обхода и ожидания клиента? ⭐⭐
- В чём отличие Visitor “на виртуальных методах” от Visitor “на шаблонах” (template-based) в C++? Какие компромиссы по типобезопасности и гибкости? ⭐⭐⭐
- Как можно реализовать Visitor так, чтобы операции были **const-correct** (например, `Visit(const Rectangle&)`)? Почему это важно? ⭐⭐
- Объясните идею избавления от boilerplate-кода `Accept()` с помощью `Visitable<T, Base>` / `ConstVisitable<T, Base>`. Почему это работает? ⭐⭐⭐
- Почему подход с `CRTP` в контексте Visitor считается идиомой C++? Какие риски и ограничения он несёт (например, сложность чтения, ошибки наследования)? ⭐⭐⭐
- Представьте, что в систему добавляют новый тип фигуры `Polygon`. Опишите два сценария:
    **а)** классический Visitor,
    **б)** Acyclic Visitor,
    и сравните объём изменений, риски и влияние на существующий код. ⭐⭐⭐

### Паттерн проектирования "Прототип"

- В чём состоит основная идея паттерна Prototype и какую проблему создания объектов он решает? ⭐
- Почему подход «создать пустой объект и скопировать поля по очереди» часто не работает в ООП? Приведите минимум 2 причины. ⭐
- Как Prototype помогает клиенту создавать объекты, не зная их конкретных типов? ⭐
- В каких ситуациях Prototype предпочтительнее, чем прямой вызов конструктора? Приведите примеры. ⭐⭐
- В каких ситуациях Prototype предпочтительнее, чем фабричный метод/абстрактная фабрика, и почему? ⭐⭐
- Что означает «классы определяются во время выполнения» в контексте Prototype? Как это влияет на архитектуру? ⭐⭐
- Чем отличается «поверхностное» (shallow) клонирование от «глубокого» (deep)? Когда нужно каждое из них? ⭐⭐
- Какие типовые сложности возникают при глубоком клонировании графа объектов с циклическими ссылками? Как их решать? ⭐⭐⭐
- Какие инварианты класса могут быть нарушены при некорректной реализации Clone()? Приведите примеры инвариантов. ⭐⭐
- Почему важно, чтобы у базового интерфейса прототипа был виртуальный деструктор? ⭐
- Почему сигнатура `unique_ptr<Base> Clone() const` чаще удачнее, чем возврат сырого указателя? Какие риски она снимает? ⭐⭐
- Какие требования накладывает реализация `Clone()` через копирующий конструктор на тип `Impl`? ⭐
- В чём состоит дублирование кода в «наивной» реализации Clone() в каждом подклассе и как CRTP помогает его убрать? ⭐⭐
- Объясните идею CRTP в `PrototypeImpl<Impl, Interface>`. Почему внутри Clone делается `static_cast<const Impl*>(this)`? ⭐⭐
- Какие риски появляются из-за `static_cast` в CRTP-реализации, и как их минимизировать? ⭐⭐⭐
- Как влияет отсутствие конструктора по умолчанию у базового класса на проектирование `PrototypeImpl`? Зачем нужен `using Base::Base`? ⭐⭐
- Какие архитектурные плюсы даёт использование реестра прототипов (Prototype Registry) по сравнению с фабрикой? ⭐⭐
- Разберите пример `ShapeGroup`: какие требования к клонированию элементов группы и почему там нужен кастомный copy-конструктор? ⭐⭐
- Почему наследование `Worker` от конкретного `Person` (в примере со слайда) является “красным флагом”? Назовите минимум 3 причины. ⭐⭐
- Как в этом примере может быть нарушен LSP? Сформулируйте возможные пред/постусловия у `Person::SpendDay()` и как их нарушит `Worker`. ⭐⭐⭐
- Что такое Fragile Base Class Problem и как он проявляется в иерархии `Person` → `Worker` при эволюции кода? ⭐⭐
- Что означает “Refused Bequest” (отвергнутое наследство) и как оно может привести к лишним полям и ухудшению производительности? ⭐⭐
- Какие подходы исправления проблем наследования от конкретного класса вы бы выбрали в разных сценариях: NVI/Template Method, композиция, стратегия, mixin? Обоснуйте. ⭐⭐⭐
- Зачем в варианте с `PersonImpl<Base>` метод `GetName()` делают `final`? Какие компромиссы и альтернативы есть? ⭐⭐
- Какие риски у решения через mixin-ы и шаблонное наследование? Как их контролировать? ⭐⭐⭐
- Какие проверки стоит добавить в `PrototypeImpl` с помощью C++20 Concepts/`static_assert`, и какие ошибки они позволяют ловить раньше? ⭐⭐
- Почему `std::any` не поддерживает «восходящее» приведение к базовому типу (`any_cast<IShape&>` при хранении `Circle`), и как это влияет на дизайн type-erasure? ⭐⭐
- Сравните два подхода “классический полиморфизм через `unique_ptr<IShape>`” и “type erasure через `std::any`”
  с точки зрения: производительности (конструирование vs вызовы), владения,
  локальности данных, расширяемости и сложности реализации. ⭐⭐⭐

### Паттерн проектирования "Строитель"

Вот **30 открытых экзаменационных вопросов** по паттерну **Builder (Строитель)**. Они проверяют не только знание структуры, но и понимание **ООП-принципов, ответственности классов, компромиссов проектирования** и применения Builder в задаче **сохранения/экспорта документа** (JSON/XML/ZIP/бинарный формат, HTML/PDF/RTF и т.д.).

---

## 30 экзаменационных вопросов по паттерну Builder

- Объясните назначение паттерна Builder своими словами и приведите пример ситуации, где он лучше конструктора или фабрики. ⭐
- Почему Builder формулируют как «отделяет конструирование сложного объекта от его представления»?
  Что именно отделяется и какие проблемы это решает? ⭐⭐
- Опишите роли **Director**, **Builder**, **ConcreteBuilder**, **Product**, **Client** и их ответственность в терминах SRP (Single Responsibility Principle). ⭐⭐
- В чём разница между Builder и Abstract Factory?
  Приведите пример, где эти паттерны выглядят похоже, но дают разные архитектурные свойства. ⭐⭐
- Почему в классическом Builder распорядитель (Director) работает через **абстрактный интерфейс Builder**,
  и что это даёт с точки зрения OCP (Open/Closed Principle)? ⭐⭐
- Какие признаки в коде указывают, что пора внедрять Builder? ⭐
- Можно ли применять Builder для простых объектов из 2–3 полей? Обоснуйте, когда это будет вредно. ⭐⭐
- В задаче «экспорт документа в разные форматы» какие сущности логично сделать продуктами Builder, а какие — частями процесса сборки? ⭐⭐
- Спроектируйте интерфейс Builder для экспорта документа так, чтобы один и тот же процесс сборки мог создавать продукты:
  JSON+images, XML+images, бинарный формат. Какие методы вы бы включили и почему? ⭐⭐⭐
- Должен ли у продукта быть общий интерфейс или базовый класс? ⭐⭐
- Что означает «продукт создаётся шаг за шагом»? Приведите пример набора шагов для сборки документа в PDF или HTML. ⭐
- Как бы вы реализовали Builder для экспорта в **Plain Text**, чтобы он корректно обрабатывал форматирование, изображения и метаданные документа? ⭐⭐
- Какие инварианты и проверки корректности удобнее делать в Builder, а какие — в Director? Обоснуйте архитектурно. ⭐⭐⭐
- В каких случаях Builder должен предоставлять доступ к «частично собранному продукту»? Приведите пример из лекции и объясните, зачем это нужно. ⭐⭐⭐
- Почему в классической реализации Builder допускается, что методы базового Builder могут быть «пустыми» (no-op)
  вместо абстрактных? Какие плюсы и минусы у этого решения? ⭐⭐⭐
- Опишите, как Builder помогает «изменять внутреннее представление продукта», не меняя код Director. Приведите пример. ⭐⭐
- Что произойдёт, если Director начнёт знать конкретные классы продукта (например, PDFDocument, HtmlDocument)?
  Какие принципы проектирования будут нарушены? ⭐⭐
- Builder обычно создаёт один продукт за один цикл сборки.
  Как обеспечить возможность повторного использования одного Builder для нескольких продуктов, и какие риски это несёт? ⭐⭐
- В чём отличие «классического Builder (Director + Builder)» от «Fluent Builder (цепочки вызовов)»? Когда какой вариант предпочтительнее? ⭐⭐
- Какие проблемы возникают, если Builder хранит слишком много состояния и становится «вторым продуктом»? Как этого избежать? ⭐⭐⭐
- Рассмотрите сценарий: экспорт документа должен быть расширяемым (добавим EPUB через месяц).
  Как Builder помогает сделать это изменение минимальным? ⭐⭐
- Назовите недостаток Builder из лекции и предложите 2 способа уменьшить количество классов без потери расширяемости. ⭐⭐⭐
- Объясните, как Builder может сочетаться с паттерном **Команда** (Command) в архитектуре приложения. ⭐⭐⭐
- В задаче экспорта без потери информации: как Builder должен работать с ресурсами (изображения, вложения) и ссылками на них, чтобы поддержать JSON/XML + отдельные файлы? ⭐⭐⭐
- Как бы вы обеспечили единый «процесс конструирования» для экспорта в HTML и PDF, если они требуют разных структур (DOM vs страницы/рендеринг)? ⭐⭐⭐
- Приведите пример ситуации, когда Director не нужен, и клиент может напрямую управлять Builder. Почему это допустимо? ⭐⭐
- Builder часто применяют для immutable объектов. Объясните, почему Builder хорошо сочетается с неизменяемостью и какие ошибки при этом допускают. ⭐⭐
- Как отличить Builder от Factory Method в реальном коде, если оба создают объекты?
  На какие признаки в API и ответственности классов вы бы смотрели? ⭐⭐
- Предложите дизайн, где один и тот же документ можно сохранить в разных форматах,
  не меняя код документа и минимально меняя код экспортёра. Какие паттерны вы бы использовали и почему? ⭐⭐⭐

### Паттерн проектирования "Мост"

- Объясните, в чём состоит ключевая идея паттерна «Мост» и какую проблему проектирования он решает. ⭐
- Что в паттерне «Мост» является **абстракцией**, а что — **реализацией**? Приведите пример на основе окон GUI. ⭐
- Почему добавление новой платформы (например, MacOS X) приводит к “взрыву количества классов” в наивной реализации UI-библиотеки? ⭐⭐
- Какие признаки в коде и структуре классов подсказывают, что пора применять «Мост»? ⭐⭐
- Что означает фраза: «Абстракция и реализация должны расширяться независимо»? Объясните на примере. ⭐⭐
- Какие риски возникают для сопровождения и тестирования, если клиентский код зависит от классов конкретной платформы? ⭐⭐
- Почему фабрика сама по себе не решает проблему сильной связности абстракции и реализации? ⭐⭐
- Опишите структуру паттерна Bridge (Abstraction, RefinedAbstraction, Implementor, ConcreteImplementor) и ответственность каждого элемента. ⭐⭐
- Какой тип связи между `Window` и `WindowImp` является ключевым в паттерне «Мост» и почему? ⭐⭐
- Какие два “непересекающихся измерения” чаще всего выделяют при применении Bridge? Приведите 2–3 пары. ⭐
- Почему в Bridge обычно используется **композиция**, а не наследование? Какие преимущества это даёт с точки зрения ООП? ⭐⭐
- Объясните, как Bridge помогает следовать принципу **Open/Closed (OCP)**. ⭐⭐
- Представьте, что вам нужно добавить новый тип окна (например, `PopupWindow`) и новую платформу (`Wayland`).
  Какие классы изменятся при использовании Bridge и какие — при наследовании без Bridge? ⭐⭐⭐
- Как в Bridge организовать возможность выбора реализации **во время выполнения**?
  Приведите сценарий, где это реально нужно. ⭐⭐
- Какие недостатки паттерна «Мост» проявляются в небольших проектах и почему его иногда считают “overengineering”? ⭐⭐
- В каких случаях Implementor стоит делать интерфейсом, а в каких — обычным классом? Обоснуйте архитектурно. ⭐⭐
- Кто должен создавать `ConcreteImplementor` в Bridge: сама `Abstraction`, клиент, фабрика или DI-контейнер? Сравните варианты и их последствия. ⭐⭐⭐
- В лекции упоминается совместное использование реализаций между несколькими объектами абстракции.
  Зачем это может быть нужно и какие проблемы при этом возникают? ⭐⭐⭐
- Как вы бы реализовали Bridge так, чтобы одна реализация могла безопасно использоваться несколькими абстракциями? ⭐⭐⭐
- Сравните паттерны **Bridge** и **Adapter**: чем отличается их цель, когда они применяются и что происходит с зависимостями в системе? ⭐⭐
- Объясните, как паттерн **Builder** может быть “построен в виде моста”: кто играет роль абстракции и кто — реализации? ⭐⭐⭐

### Архитектура GUI-приложений. Document-View

- Достоинства и недостатки подхода Smart UI.
- Из каких ключевых компонентов состоит приложение, использующее подход Document-View? За что отвечают эти компоненты?
- Постройте диаграмму классов приложения, использующего этот подход.
- Какие паттерны проектирования лежат в основе Document-View?
- Достоинства и недостатки подхода Document-View.
- Каким образом происходит обновление представления при изменении документа?
- Каким образом действия пользователя в одном представлении могут привести к обновлению других представлений этого документа?
- Напишите приложение, построенное с помощью подхода Document-View. Приложение должно отображать в окне сумму двух целых чисел, которые пользователь ввёл в поля ввода в окне. Сумма обновляется всякий раз, когда пользователь обновил содержимое поля ввода.

### Архитектура GUI-приложений. Model-View-Controller

- Достоинства и недостатки подхода Smart UI.
- Из каких ключевых компонентов состоит приложение, использующее подход Model-View-Controller? За что отвечают эти компоненты?
- Постройте диаграмму классов приложения, использующего этот подход.
- Какие паттерны проектирования лежат в основе Model-View-Controller?
- Достоинства и недостатки подхода Model-View-Controller.
- Каковы сходства и отличия подходов MVC и Document-View.
- Напишите приложение, построенное с помощью подхода Model-View-Controller. Приложение должно отображать в окне сумму двух целых чисел, которые пользователь ввёл в поля ввода в окне. Сумма обновляется всякий раз, когда пользователь обновил содержимое поля ввода.

### Архитектура GUI-приложений. Model-View-Presenter

- Достоинства и недостатки подхода Smart UI.
- Из каких ключевых компонентов состоит приложение, использующее подход Model-View-Presenter? За что отвечают эти компоненты?
- Постройте диаграмму классов приложения, использующего этот подход.
- Какие паттерны проектирования лежат в основе Model-View-Presenter?
- Достоинства и недостатки подхода Model-View-Presenter.
- Каковы сходства и отличия подходов MVP и MVC.
- Напишите приложение, построенное с помощью подхода Model-View-Presenter. Приложение должно отображать в окне сумму двух целых чисел, которые пользователь ввёл в поля ввода в окне. Сумма обновляется всякий раз, когда пользователь обновил содержимое поля ввода.

## Принципы проектирования ПО

### Отношения между классами

- Визуализация структуры программы на диаграмме классов.
  - Как обозначаются классы на диаграмме классов?
  - Как обозначаются абстрактные классы?
  - Как обозначить видимость методов и данных на диаграмме классов?
  - Как обозначаются статические методы и данные на диаграмме классов?
  - Как обозначаются абстрактные методы?
- Композиция.
  - Что такое композиция?
  - Когда возникает отношение композиции между классами?
  - Обозначение композиции на диаграмме классов.
  - Приведите пример использования композиции в реальной программе.
  - Сокрытие данных при композиции.
- Агрегация
  - Что такое агрегация?
  - Когда возникает отношение агрегации?
  - Обозначение агрегации на диаграмме классов.
  - Сокрытие данных при агрегировании.
  - Приведите пример агрегации в реальной программе.
  - Отличие агрегации и композиции.
- Зависимость
  - Что такое зависимость?
  - Когда возникает отношение зависимости между классами?
  - Обозначение зависимости на диаграмме классов.
  - Что такое транзитивность зависимостей?
  - Приведите пример зависимости в реальной программе.
- Наследование
  - Что такое наследование? Какое отношение между классами существует при наследовании?
  - Как наследование обозначается на диаграмме классов?
- Интерфейсы
  - Как отображаются интерфейсы на диаграмме классов.
  - Каким отношениями могут и не могут быть связаны интерфейсы с другими программными сущностями?
  - Как на диаграмме классов обозначается класс, реализующий интерфейс?
  - Может ли один интерфейс быть унаследован от другого?

### Принцип единственной ответственности (SRP)

- В чём заключается Принцип Единственной Ответственности?
- Приведите пример нарушения SRP на диаграмме классов. Выполните рефакторинг, чтобы соблюсти SRP.
- Какие выгоды от следования принципу SRP? Обоснуйте свой ответ.
- Как соблюдение и нарушение SRP влияет на поддерживаемость кода? Обоснуйте свой ответ.
- Каким образом нужно проектировать программу, чтобы соблюсти этот принцип?
- Как соблюдение и нарушение SRP влияет на тестируемость кода? Обоснуйте свой ответ.
- Выразите своё отношение к следующим утверждениям:
  - Согласно SRP класс должен иметь только один метод.
  - SRP имеет смысл применять только в больших проектах.
  - Следование SRP приводит к чрезмерному количеству классов.
  - В соответствии с SRP у класса должна быть ровно одна зона ответственности.
  - Принцип единственной ответственности применим только в объектно-ориентированных программах.

### Принцип открытости-закрытости (OCP)

- В чём заключается принцип открытости-закрытости?
- В чём важность этого принципа в архитектуре ПО?
- Приведите пример нарушения OCP на диаграмме классов. Какие недостатки имеет архитектура программы? Выполните рефакторинг так, чтобы архитектура следовала этому принципу.
- Какая практическая польза от следования принципу открытости-закрытости? Обоснуйте свой ответ.
- Каким образом нужно проектировать программу, чтобы соблюсти этот принцип?
- Как соблюдение и нарушение OCP влияет на легкость поддержки кода? Обоснуйте свой ответ.
- Как соблюдение и нарушение OCP влияет на легкость тестирования? Обоснуйте свой ответ.
- Какие паттерны проектирования помогают соблюдать этот принцип?
- Выразите своё отношение к следующим утверждениям:
  - Следование OCP означает, что не нужно никогда вносить изменения в существующий код.
  - Принцип открытости-закрытости применим только в объектно-ориентированных программах.
  - Следование OCP приводит к излишней сложности кода.
  - OCP имеет смысл применять только в больших программах.

### Принцип подстановки Лисков (LSP)

- В чём заключается принцип подстановки Лисков?
- Почему этот принцип важен в архитектуре ПО?
- Приведите примеры нарушения LSP.
- Каким образом нужно проектировать программу, чтобы соблюсти этот принцип?
- Что такое ковариантность и контрвариантность и как они связаны с этим принципом?
- Как автоматически протестировать соблюдение LPS?
- Как обнаружить нарушение этого принципа при ревью кода?
- Каковы последствия нарушения принципа LSP?

### Принцип разделения интерфейса (ISP)

- В чём заключается Принцип Разделения Интерфейса?
- Как этот принцип связан с принципом единственной ответственности?
- Приведите пример нарушения ISP на диаграмме классов. Какой рефакторинг вы бы провели, чтобы соблюсти принцип ISP.
- Как нарушение ISP влияет на легкость тестирования и поддержки кода? Обоснуйте свой ответ.
- Каким образом нужно проектировать программу, чтобы соблюсти этот принцип?
- Представьте, что вы проводите ревью кода. Как вы определите, нарушает ли код принцип разделения интерфейса?
- Как принцип этот принцип связан с принципом инверсии зависимостей?
- Выразите своё отношение к утверждениям:
  - В соответствии ISP каждый метод должен быть выделен в отдельный интерфейс.
  - ISP может быть применён только в объектно-ориентированных программах.
  - Следование ISP приводит к чрезмерному количеству интерфейсов.
  - ISP имеет смысл применять только в больших проектах.

### Принцип инверсии зависимостей (DIP)

- В чём заключается принцип инверсии зависимостей?
- В чём важность принципа инверсии зависимостей в архитектуре ПО?
- Приведите пример нарушения DIP на диаграмме классов. Проведите рефакторинг, чтобы соблюсти этот принцип.
- Каким образом нужно проектировать программу, чтобы соблюсти этот принцип?
- Какие паттерны проектирования помогают соблюдать DIP?
- Каковы последствия от нарушения DIP? Обоснуйте свой ответ.
- Как следование DIP влияет на легкость тестирования и поддержки кода?
- Приведите пример использования DIP в реальном приложении.

### Компоненты и их сочетаемость

- В чём отличие связности (Cohesion) и сцепленность (Coupling)?
- О чём говорит принцип "High Cohesion, Low Coupling"?
- Что такое устойчивость компонента?
- Метрики устойчивости компонента. Как вычислить неустойчивость компонента?
- В чём заключается принцип устойчивых зависимостей (SDP)?
- Определите устойчивость компонентов и нарушение/соблюдение принципа устойчивых зависимостей по диаграмме классов.
- Как исправить нарушение SDP?
- В чём заключается принцип устойчивости абстракций (SAP)?
- Метрики абстрактности компонента. Как вычислить меру абстрактности компонента?
- Диаграмма устойчивости/абстрактности компонентов. Отобразить компонент на диаграмме устойчивости/абстрактности.
- Ключевые зоны диаграммы: зона боли, зона бесполезности, главная последовательность.
- Как вычислить расстояние до главной последовательности?
