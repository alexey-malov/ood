# Вопросы к экзамену

- [Вопросы к экзамену](#вопросы-к-экзамену)
  - [Паттерны проектирования](#паттерны-проектирования)
    - [Паттерн проектирования "Стратегия"](#паттерн-проектирования-стратегия)
    - [Паттерн проектирования "Наблюдатель"](#паттерн-проектирования-наблюдатель)
    - [Паттерн проектирования "Декоратор"](#паттерн-проектирования-декоратор)
    - [Паттерн проектирования "Абстрактная фабрика"](#паттерн-проектирования-абстрактная-фабрика)
    - [Паттерн проектирования "Фабричный метод"](#паттерн-проектирования-фабричный-метод)
    - [Паттерны проектирования "Команда" и "Хранитель"](#паттерны-проектирования-команда-и-хранитель)
    - [Паттерн проектирования "Адаптер"](#паттерн-проектирования-адаптер)
  - [30 экзаменационных вопросов по паттерну «Адаптер»](#30-экзаменационных-вопросов-по-паттерну-адаптер)
    - [Паттерн проектирования "Шаблонный метод"](#паттерн-проектирования-шаблонный-метод)
    - [Паттерн проектирования "Итератор"](#паттерн-проектирования-итератор)
    - [Паттерн проектирования "Компоновщик"](#паттерн-проектирования-компоновщик)
    - [Паттерн проектирования "Состояние"](#паттерн-проектирования-состояние)
    - [Паттерн проектирования "Заместитель"](#паттерн-проектирования-заместитель)
    - [Паттерн проектирования "Посетитель"](#паттерн-проектирования-посетитель)
    - [Паттерн проектирования "Прототип"](#паттерн-проектирования-прототип)
    - [Паттерн проектирования "Строитель"](#паттерн-проектирования-строитель)
    - [Паттерн проектирования "Мост"](#паттерн-проектирования-мост)
    - [Архитектура GUI-приложений. Document-View](#архитектура-gui-приложений-document-view)
    - [Архитектура GUI-приложений. Model-View-Controller](#архитектура-gui-приложений-model-view-controller)
    - [Архитектура GUI-приложений. Model-View-Presenter](#архитектура-gui-приложений-model-view-presenter)
  - [Принципы проектирования ПО](#принципы-проектирования-по)
    - [Отношения между классами](#отношения-между-классами)
    - [Принцип единственной ответственности (SRP)](#принцип-единственной-ответственности-srp)
    - [Принцип открытости-закрытости (OCP)](#принцип-открытости-закрытости-ocp)
    - [Принцип подстановки Лисков (LSP)](#принцип-подстановки-лисков-lsp)
    - [Принцип разделения интерфейса (ISP)](#принцип-разделения-интерфейса-isp)
    - [Принцип инверсии зависимостей (DIP)](#принцип-инверсии-зависимостей-dip)
    - [Компоненты и их сочетаемость](#компоненты-и-их-сочетаемость)

## Паттерны проектирования

### Паттерн проектирования "Стратегия"

- В чём принципиальная разница между умением писать код и умением проектировать систему?
   ⭐⭐
- Почему требования к программным системам почти всегда изменяются, и как это влияет на выбор архитектуры?
   ⭐⭐
- Почему паттерны проектирования не являются «готовыми решениями»?
   ⭐
- Как паттерн «Стратегия» помогает избежать велосипедостроения?
   ⭐⭐
- В каких ситуациях применение паттерна «Стратегия» может быть избыточным или вредным? Приведите пример.
   ⭐⭐⭐
- Какие архитектурные проблемы проявились в начальной реализации «утиного симулятора» при добавлении `Fly()`?
   ⭐⭐
- Почему «локальное изменение кода привело к нелокальным эффектам» — особенно опасная ситуация в командной разработке?
   ⭐⭐
- Почему переопределение `Fly()` и `Quack()` в подклассах плохо масштабируется?
   ⭐⭐
- Какие проблемы в примере с утками относятся к нарушению SRP, а какие — к нарушению OCP?
   ⭐⭐⭐
- Что такое «хрупкий базовый класс» и почему это фундаментальная проблема ООП?
    ⭐⭐⭐
- Почему решение с интерфейсами `Flyable` / `Quackable` и `dynamic_cast` считается архитектурно слабым?
    ⭐⭐
- По каким признакам в существующем коде можно понять, что пора заменить наследование композицией?
    ⭐⭐⭐
- Почему принцип «отделяйте изменяемое от неизменяемого» является ключевым для стратегии?
    ⭐⭐
- Как независимость изменений полёта и кряканья влияет на структуру классов?
    ⭐⭐
- Как принцип *Program to an interface, not an implementation* реально снижает стоимость изменений?
    ⭐⭐⭐
- Дайте развёрнутое определение паттерна «Стратегия» и опишите роли Контекста и Стратегии.
    ⭐⭐
- Почему делегирование поведения снижает связанность системы?
    ⭐⭐
- Какие преимущества и риски даёт динамическая смена стратегии в рантайме?
    ⭐⭐
- В каких случаях Контекст стоит делать интерфейсом, а в каких — конкретным классом?
    ⭐⭐⭐
- Почему возможность переиспользования стратегий другими объектами — признак хорошей абстракции?
    ⭐⭐⭐
- Могут ли стратегии иметь собственное состояние?
    ⭐
- Когда наличие состояния в стратегии — оправданное решение, а когда — симптом вырождающейся архитектуры?
    ⭐⭐⭐
- В чём разница между хранением состояния в Контексте и в Стратегии?
    ⭐⭐
- Почему попытка «хранить всё состояние в Контексте» может привести к плохому дизайну?
    ⭐⭐⭐
- Как принципы YAGNI и KISS влияют на решение о добавлении состояния в стратегию?
    ⭐⭐⭐
- Что означает `const`-метод в интерфейсе стратегии с точки зрения контракта?
    ⭐⭐
- Почему опасно объявлять командные методы стратегии `const`, даже если реализация «умеет» это обойти?
    ⭐⭐⭐
- Как LSP и CQS ограничивают проектирование интерфейсов стратегий в C++?
    ⭐⭐⭐
- В каких случаях допустима логическая константность (`mutable`), и какие архитектурные риски она несёт?
    ⭐⭐⭐
- Кто должен определять интерфейс стратегии — разработчик Контекста или разработчик стратегий? Почему?
    ⭐⭐⭐

### Паттерн проектирования "Наблюдатель"

- Дайте определение паттерна проектирования «Наблюдатель» и опишите проблему, которую он решает. ⭐
- Какие роли выделяются в паттерне «Наблюдатель» и какова ответственность каждой из них? ⭐
- Что означает отношение «один-ко-многим» в контексте паттерна «Наблюдатель»? ⭐
- Приведите пример использования паттерна «Наблюдатель» из реальной жизни, не связанный с программированием. ⭐
- Почему паттерн «Наблюдатель» относят к поведенческим паттернам? ⭐
- В чем заключается основная проблема наивной реализации обновления зависимых объектов (на примере WeatherData)? ⭐⭐
- Почему привязка субъекта к конкретным классам наблюдателей считается плохим архитектурным решением? ⭐⭐
- Какие принципы SOLID нарушаются в наивной реализации WeatherData и почему? ⭐⭐
- Объясните, что означает «инкапсуляция переменной части» и как паттерн «Наблюдатель» помогает её достичь. ⭐⭐
- Почему введение общего интерфейса наблюдателя является ключевым шагом при применении паттерна? ⭐⭐
- В чем состоит идея слабой связанности (loose coupling) и как паттерн «Наблюдатель» её обеспечивает? ⭐⭐
- Опишите жизненный цикл наблюдателя: регистрация, получение уведомлений, отписка. ⭐⭐
- В каких случаях имеет смысл динамически добавлять и удалять наблюдателей во время выполнения программы? ⭐⭐
- Чем модель вытягивания (pull model) отличается от модели проталкивания (push model)? ⭐⭐
- Какие преимущества и недостатки у pull-модели в сравнении с push-моделью? ⭐⭐
- Как реализовать подписку наблюдателей только на интересующие их изменения состояния субъекта? ⭐⭐⭐
- Какие проблемы могут возникнуть, если наблюдатель наблюдает более чем за одним субъектом, и как их решать? ⭐⭐⭐
- Почему важно, чтобы субъект находился в согласованном состоянии перед оповещением наблюдателей? ⭐⭐⭐
- Как паттерн «Шаблонный метод» может использоваться совместно с паттерном «Наблюдатель»? ⭐⭐⭐
- Кто должен инициировать оповещение наблюдателей — субъект или клиент — и какие компромиссы есть у каждого подхода? ⭐⭐⭐
- Какие дополнительные сложности возникают при реализации паттерна «Наблюдатель» в языках без сборщика мусора? ⭐⭐⭐
- Что такое «висячие ссылки» в контексте паттерна «Наблюдатель» и как их избежать? ⭐⭐⭐
- Допустимо ли, чтобы метод Update у наблюдателя возвращал значение, и как это может повлиять на поведение субъекта? ⭐⭐⭐
- В каких случаях наблюдателям разрешается изменять состояние субъекта, и какие риски это несет? ⭐⭐⭐
- Как обеспечить расширяемость системы, не модифицируя код субъекта при добавлении новых типов наблюдателей? ⭐⭐⭐
- В чем отличие классической объектно-ориентированной реализации паттерна от функционального варианта с callback-функциями? ⭐⭐⭐
- Какие преимущества дает использование библиотек сигналов и слотов (например, boost::signals2) по сравнению с ручной реализацией Observer? ⭐⭐⭐
- Как паттерн «Наблюдатель» соотносится с принципом «программируй на уровне интерфейсов, а не реализаций»? ⭐⭐⭐
- В каких ситуациях использование паттерна «Наблюдатель» может привести к ухудшению архитектуры или производительности? ⭐⭐⭐
- Как Наблюдатель может указать, в каких обновлениях он заинтересован? ⭐⭐⭐
- Может ли Субъект выступать в роли Наблюдателя? Может ли Наблюдатель выступать в роли Субъекта? Приведите примеры. ⭐⭐

### Паттерн проектирования "Декоратор"

- Объясните, какую проблему решает паттерн «Декоратор» и почему попытка решить её только наследованием приводит к «комбинаторному взрыву» классов. ⭐⭐
- В чём ключевое отличие «расширения поведения» через декоратор от «расширения поведения» через наследование? Приведите пример из домена «кофейня». ⭐⭐
- Опишите роли участников паттерна Decorator (Component, ConcreteComponent, Decorator, ConcreteDecorator) и сопоставьте их с вашими классами напитков/добавок. ⭐⭐
- Почему важно, что декоратор имеет тот же тип (реализует тот же интерфейс), что и декорируемый объект? Как это связано с полиморфизмом и LSP? ⭐⭐
- Объясните, как в цепочке декораторов вычисляется стоимость напитка (по шагам), и какие гарантии корректности даёт такая структура. ⭐
- Какие признаки подсказывают, что в задаче следует применить декоратор, а не просто добавить методы в базовый класс? ⭐⭐
- Сравните подход «флаги в базовом классе» и подход «декораторы»: какие риски и ограничения есть у каждого, и почему флаги нарушают OCP? ⭐⭐
- Какие «странные комбинации» появляются при реализации через флаги? Как в декораторе можно ограничивать/валидировать недопустимые комбинации? ⭐⭐⭐
- Объясните принцип Open/Closed (OCP) на примере добавления новой добавки (например, «ванильный сироп»): что нужно менять в варианте с флагами и что — в варианте с декоратором? ⭐⭐
- Почему композиция считается более гибкой, чем наследование, в контексте динамического добавления поведения? Приведите пример «во время выполнения». ⭐⭐
- Какие недостатки могут появиться у декоратора по сравнению с наследованием (производительность, отладка, сложность), и как их обычно смягчают? ⭐⭐⭐
- В каких случаях использование декоратора будет избыточным? Назовите критерии и приведите пример. ⭐⭐
- Чем декоратор отличается от прокси и адаптера, если внешне они могут выглядеть похоже (обёртка вокруг объекта)? ⭐⭐⭐
- Почему в `CondimentDecorator` методы `GetDescription()` и `GetCost()` целесообразно сделать `final`? Какие проблемы возникнут, если их разрешить переопределять? ⭐⭐⭐
- Объясните, как в `CondimentDecorator` проявляется паттерн «Шаблонный метод»: где «скелет алгоритма», а где «шаги, делегируемые подклассам»? ⭐⭐
- Почему «шаги алгоритма» (`GetCondimentCost`, `GetCondimentDescription`) можно сделать `private virtual`? Какие архитектурные преимущества это даёт? ⭐⭐⭐
- Как бы вы реализовали «двойную порцию шоколада» в модели с декораторами? Приведите минимум два подхода и сравните их. ⭐⭐
- Какие требования к владению объектом и управлению временем жизни возникают при реализации декоратора? Почему в примере используется `unique_ptr`? ⭐⭐
- Что изменится, если вместо `unique_ptr` использовать `shared_ptr`? Какие новые риски и возможности это создаст для цепочек декораторов? ⭐⭐⭐
- Как декоратор влияет на тестируемость системы? Опишите стратегию юнит-тестирования для базового напитка и для конкретной добавки-декоратора. ⭐⭐
- Как можно реализовать «снятие декорации» (unwrap) или интроспекцию цепочки декораторов, не нарушая инкапсуляцию? ⭐⭐⭐
- Какие ошибки проектирования часто допускают при внедрении декоратора (например, «захардкодить цены в одном месте», «слишком много обязанностей»)? Как их избежать? ⭐⭐⭐
- В примере со строками `StringTransformer` играет роль «интерфейса компонента». Какие свойства должны быть у такого интерфейса, чтобы декораторы хорошо композировались? ⭐⭐
- Почему ручная комбинация преобразователей строк (функции типа `UpperCaseWithSquareBrackets`) приводит к той же проблеме, что и наследование в примере кофейни? ⭐⭐
- Объясните, что делает функция `Decorate(t, d)` в функциональном стиле и как она связана с идеей «оборачивания» в ООП-декораторе. ⭐⭐
- В `Decorate` используется перемещение и `forward`. Какие проблемы с производительностью/корректностью решает perfect forwarding в таком коде? ⭐⭐⭐
- Какой смысл несёт «синтаксический сахар» (например, оператор `|` для строковых декораторов или `<<` для напитков)? Какие риски он несёт для читаемости и поддержки? ⭐⭐
- Приведите пример из реальной разработки, где декоратор используется повсеместно (например, middleware, I/O streams).
  Объясните, как там устроена «цепочка» и что именно добавляют декораторы. ⭐⭐
- Предложите дизайн декоратора для HTTP-клиента, который добавляет авторизацию, логирование и кэширование.
  Как вы определите порядок декораторов и почему? ⭐⭐⭐
- Представьте, что нужно добавить новое требование: «некоторые добавки конфликтуют друг с другом» и «цены зависят от времени суток».
  Как бы вы расширили решение на декораторах? ⭐⭐⭐

### Паттерн проектирования "Абстрактная фабрика"

- Объясните, какую проблему «Абстрактная фабрика» решает лучше, чем «простая фабрика» и «фабричный метод». ⭐⭐
- Что именно скрывает от клиента абстрактная фабрика кроме конкретных классов продуктов? ⭐⭐
- Как «Абстрактная фабрика» помогает соблюдать DIP? Опишите зависимости «до» и «после». ⭐⭐
- Что считается «семейством продуктов» и почему важно создавать их согласованно? ⭐⭐
- В каких случаях абстрактная фабрика превращается в God Factory и как это распознать по симптомам в коде? ⭐⭐
- Опишите стратегию тестирования кода, который использует абстрактную фабрику: что мокается и что проверяется? ⭐⭐
- Почему «неполные семейства» (часть create* не реализована) — архитектурная проблема?
  Какие варианты дизайна решают её? ⭐⭐⭐
- Как добавление нового продукта в семейство (новый метод `CreateX`) влияет на существующий код?
  Как минимизировать ущерб? ⭐⭐⭐
- Когда вместо абстрактной фабрики лучше применить Builder? Опишите критерии выбора. ⭐⭐
- Приведите пример «протекающей абстракции» при использовании абстрактной фабрики и объясните, что это означает. ⭐⭐⭐
- Как организовать выбор конкретной фабрики (NY vs Chicago) так, чтобы бизнес-код не знал о регионах/платформах? ⭐⭐⭐
- Чем опасна фабрика-синглтон с глобальным состоянием в контексте абстрактной фабрики? ⭐⭐
- Как абстрактная фабрика помогает «прибить» совместимость ингредиентов (NY-соус + NY-сыр)?
  Почему это сложно обеспечить без неё? ⭐⭐
- Опишите вариант реализации фабрики в функциональном стиле (через функции/лямбды). Когда это оправдано? ⭐⭐
- Какие параметры допустимо передавать в `IUIFactory::CreateLabel` и какие — недопустимо, и почему? ⭐⭐
- Предложите дизайн API фабрики UI-элементов так, чтобы клиент не передавал платформенные хендлы. ⭐⭐⭐
- Что такое composition root и почему он важен при работе с абстрактными фабриками? ⭐⭐
- Чем «фабрика фабрик» отличается от корректного выбора семейства через composition root? ⭐⭐⭐
- Как бы вы реализовали переключение семейства по feature-flag без протекания деталей в домен? ⭐⭐⭐
- В каких ситуациях допустимо держать в фабрике кэш и состояние? Когда это превращается в проблему? ⭐⭐⭐
- Объясните, как абстрактная фабрика помогает снижать стоимость изменения сигнатур конструкторов продуктов. ⭐⭐
- Какие риски создаёт использование строковых ключей для выбора конкретного продукта внутри фабрики? Чем заменить? ⭐⭐
- Как организовать регистрацию продуктов/креаторов в фабрике, чтобы добавление новых типов не требовало редактирования `if/else`? ⭐⭐
- Приведите пример, когда абстрактная фабрика не нужна, и её использование ухудшит дизайн (YAGNI). ⭐⭐
- Какие признаки того, что вы неправильно выбрали «ось вариативности» и вам нужен другой паттерн (Strategy/Bridge/DI)? ⭐⭐⭐
- Опишите компромисс: «больше интерфейсов и классов» vs «гарантированная совместимость».
  Как бы вы аргументировали решение команде? ⭐⭐⭐
- Как обеспечить, чтобы продукты одного семейства не создавали напрямую продукты другого семейства? ⭐⭐⭐
- Как связать абстрактную фабрику с фабричным методом в одном решении? ⭐⭐

### Паттерн проектирования "Фабричный метод"

- Сформулируйте идею паттерна «Фабричный метод» своими словами и объясните, где в PizzaStore он проявляется. ⭐
- Почему фабричный метод часто сочетается с шаблонным методом? Что фиксируется, а что вариативно? ⭐⭐
- Какие зависимости убирает фабричный метод по сравнению с прямым созданием (`new`/`make_unique`) в клиенте? ⭐⭐
- Как фабричный метод помогает соблюдать OCP на примере расширения ассортимента пиццы? ⭐⭐
- В чём различие между «простая фабрика» и «фабричный метод» на уровне расширяемости и наследования? ⭐⭐
- Опишите параметризованный фабричный метод и его типичные проблемы. Как их лечить? ⭐⭐
- Опишите непараметризованный фабричный метод. В каких сценариях он предпочтительнее? ⭐⭐
- Почему «параллельные иерархии классов» считаются недостатком FactoryMethod и когда это оправдано? ⭐⭐⭐
- Как избежать комбинаторного взрыва, если фабричных методов несколько и продуктов много? ⭐⭐⭐
- Какие есть способы ограничить переопределение алгоритма конструирования объекта в базовом классе? ⭐⭐
- Объясните, почему ошибка типа «забыли вызвать `Pizza::Cut()`» — системная проблема дизайна,
  а не баг конкретного разработчика. ⭐⭐
- Какая часть кода должна оставаться в базовом классе Creator, а какая — в подклассах? Назовите критерии. ⭐⭐
- Как фабричный метод соотносится с DIP: кто от кого должен зависеть? ⭐⭐
- Почему использование строковых параметров (`type == "cheese"`) — риск? Предложите улучшение API. ⭐⭐
- Какие варианты обработки ошибок создания продукта вы предложите (исключения/Optional/Result)
  и как это влияет на дизайн Creator? ⭐⭐⭐
- Как тестировать базовый алгоритм Creator независимо от конкретных продуктов? ⭐⭐
- Как тестировать конкретный подкласс Creator так, чтобы не дублировать тесты базового алгоритма? ⭐⭐⭐
- Когда FM превращается в анти-паттерн: «переабстракция на вырост»? Приведите признаки. ⭐⭐
- Как выглядит «протекающая абстракция» в FM и как её исправить (когда клиент всё равно знает ConcreteProduct)? ⭐⭐⭐
- В чём смысл требования: «Creator не должен делать предположений о конкретном типе продукта»?
  Как это нарушается на практике? ⭐⭐⭐
- Как бы вы рефакторили код DependentPizzaStore, чтобы применить фабричный метод и уменьшить зависимости? ⭐⭐
- Что изменится в проекте при добавлении новой пиццы и нового региона при использовании FM? Сравните с подходом без FM. ⭐⭐⭐
- Как выбрать между FM и Strategy для задачи «выбор типа создаваемого объекта во время выполнения»? ⭐⭐⭐
- Какие компромиссы возникают при попытке сделать фабричный метод статическим? ⭐⭐
- Как фабричный метод влияет на способность кэшировать/переиспользовать продукты или их части? ⭐⭐⭐
- В C++: какие вопросы владения ресурсами (unique_ptr/shared_ptr) особенно важны при реализации FM? ⭐⭐
- Как обеспечить, что разные подклассы Creator не нарушат инварианты продукта (например, обязательные шаги подготовки)? ⭐⭐⭐
- Приведите пример, где FM лучше заменить на Abstract Factory, и объясните, почему FM не справляется. ⭐⭐⭐

### Паттерны проектирования "Команда" и "Хранитель"

- Объясните, какую архитектурную проблему решает паттерн **Command** и почему прямой вызов методов получателя из UI считается плохим решением. ⭐
- В чём различие ролей **Client**, **Invoker**, **Command**, **Receiver**? Приведите пример для каждого участника из системы “меню → робот”. ⭐
- Почему **инициатор (Invoker)** не должен создавать команды? Какие зависимости возникнут, если он будет знать конкретные классы команд? ⭐⭐
- Какие преимущества даёт то, что запрос представлен объектом (Command), а не вызовом метода? Назовите минимум 3 практических эффекта. ⭐
- Что именно должно храниться внутри объекта команды: получатель, параметры, логика, состояние? Обоснуйте распределение ответственности. ⭐⭐
- Объясните, что означает “ослабление связности” в контексте Command. Какая связность уменьшается и какие зависимости остаются? ⭐⭐
- Как паттерн Command помогает реализовать **конфигурирование действий** (например, связывание фраз с командами в меню)? ⭐
- Как бы вы расширили пример с роботом, чтобы добавить команду “идти 10 секунд”, не меняя код меню? Какие параметры и где вы бы хранили? ⭐⭐
- В каких случаях команда может быть реализована не классом, а **функциональным объектом** (`std::function`, лямбда)? Какие плюсы и минусы у такого подхода? ⭐⭐
- Как изменится тестируемость системы при переходе от прямых вызовов к Command? Какие части станет легче мокать и проверять? ⭐⭐
- Опишите архитектуру **Undo/Redo** на базе Command: какие структуры данных нужны и какие операции выполняются при Undo и Redo. ⭐⭐
- Почему не каждая операция естественно обратима? Приведите примеры команд, для которых сложно или дорого реализовать `Unexecute()`. ⭐⭐
- Объясните, как реализовать **макрокоманду** с возможностью отката изменений? ⭐⭐
- Что такое **макрокоманда** и какие паттерны в ней сочетаются? ⭐⭐
- Как бы вы реализовали макрокоманду так, чтобы при ошибке в середине выполнения система оставалась в консистентном состоянии? ⭐⭐⭐
- В чём проблема “избыточной истории изменений” в редакторах и почему она ухудшает UX Undo/Redo? ⭐
- Объясните идею **склеивания (coalescing)** соседних команд редактирования. По каким признакам можно понять, что команды нужно объединить? ⭐⭐
- Чем отличаются стратегии `AddEdit()` и `ReplaceEdit()` при работе с историей изменений в примере из лекции?
  В каких случаях полезна каждая из них? ⭐⭐
- В примере `EditText::ReplaceEditImpl()` используется сравнение `otherEditText->m_newText == m_oldText`.
  Почему это важная проверка и какую семантику она выражает? ⭐⭐⭐
- Какие риски появляются при “умных командах”, которые пытаются оптимизировать историю (например, склеивание)?
  Как это может повлиять на корректность Undo/Redo? ⭐⭐⭐
- Опишите две крайности “интеллектуальности команд” и объясните, почему они вредны с точки зрения принципов ООП и SOLID. ⭐⭐
- Где должна находиться бизнес-логика: в команде или в получателе? Приведите критерии принятия решения. ⭐⭐
- Какие дополнительные возможности появляются, если команды можно **сериализовать и десериализовать**?
  Какие ограничения это накладывает на дизайн команд? ⭐⭐⭐
- Как реализовать асинхронное выполнение команд (очередь задач, выполнение в другом потоке)? ⭐⭐⭐
- Чем Command-подход к Undo/Redo отличается от подхода “сохранить снимок состояния”? В каких случаях Command выгоднее? ⭐⭐
- Сформулируйте идею паттерна **Memento** и объясните, как он сохраняет инкапсуляцию. ⭐⭐
- Опишите роли **Originator**, **Memento**, **Caretaker** и их взаимодействие. Кто имеет право читать/изменять состояние? ⭐⭐
- Почему “классическая версия” Memento может потенциально нарушать инкапсуляцию, и как “альтернативная версия” решает эту проблему? ⭐⭐⭐
- В каких случаях Memento может быть слишком дорогим по памяти? Какие оптимизации можно применить? ⭐⭐⭐
- Спроектируйте систему Undo/Redo для редактора, где часть операций реализована через Command, а часть — через Memento.
  Как бы вы комбинировали их и почему? ⭐⭐⭐

### Паттерн проектирования "Адаптер"

Конечно! Ниже — **30 открытых экзаменационных вопросов** по паттерну **«Адаптер»**, которые проверяют не только знание определения, но и **глубину понимания ООП, проектирования, зависимостей, архитектурных компромиссов**, а также связь с материалом твоих слайдов (утки/индюшки, изменение интерфейса библиотеки, препятствия, сравнение с декоратором, функциональный адаптер, ListView datasource и т.д.).

---

## 30 экзаменационных вопросов по паттерну «Адаптер»

- Объясните паттерн «Адаптер» своими словами и приведите **пример из промышленной разработки**, где он является наиболее уместным решением. ⭐
- Почему изменение интерфейса внешней библиотеки часто приводит к «поломке» системы? Какие свойства архитектуры делают систему особенно уязвимой к таким изменениям? ⭐⭐
- В каких ситуациях **переписывание клиентского кода** является плохой альтернативой адаптеру? Оцените это с точки зрения стоимости сопровождения и рисков. ⭐⭐
- Опишите роли **Client / Target / Adapter / Adaptee** и объясните, какие зависимости между ними допустимы, а какие являются архитектурной ошибкой. ⭐⭐
- Почему клиент «не должен знать про наличие адаптера»? Какие проблемы возникнут, если клиент начнёт зависеть от конкретного адаптера? ⭐⭐
- Рассмотрите пример «утки и индюшки». Какие именно несовместимости интерфейсов присутствуют в этом примере и как адаптер их устраняет? ⭐
- В примере с утками метод `Fly()` адаптера вызывает `Fly()` индюшки 5 раз. Почему это важно с точки зрения **семантической адаптации**, а не только совпадения сигнатур? ⭐⭐
- Что произойдёт, если адаптер будет реализован формально (методы совпадают), но **семантика поведения** не соответствует ожиданиям клиента? Приведите пример ошибки проектирования. ⭐⭐
- Объясните разницу между **объектным адаптером** и **классовым адаптером**. Когда вы выберете один подход вместо другого? ⭐⭐
- Какой адаптер обычно считается более гибким: объектный или классовый? Как это связано с принципами ООП? ⭐⭐
- Какие преимущества даёт классовый адаптер в C++ и какие ограничения он накладывает на архитектуру системы? ⭐⭐
- В каких случаях множественное наследование в классовом адаптере может стать источником проблем?
  Какие это проблемы (не только технические, но и архитектурные)? ⭐⭐⭐
- Рассмотрите слайд про «объём работы»: почему сложность адаптера пропорциональна размеру Target-интерфейса?
  Какие практики помогают уменьшить эту стоимость? ⭐⭐
- Что такое «замаскированные зависимости от конкретных классов» и почему они мешают внедрению адаптера?
  Приведите пример кода или ситуации. ⭐⭐⭐
- Почему адаптер легче внедрять в код, который зависит от интерфейсов? Как это связано с DIP (Dependency Inversion Principle)? ⭐⭐
- Можно ли считать адаптер нарушением SRP (Single Responsibility Principle)?
  Аргументируйте ответ и поясните, где проходит граница ответственности адаптера. ⭐⭐⭐
- Как адаптер помогает реализовать принцип Open/Closed? Какие изменения в системе должны происходить при смене внешнего API? ⭐⭐
- Чем адаптер отличается от фасада (Facade) по цели и эффекту на архитектуру? Приведите пример, где один паттерн подходит, а другой — нет. ⭐⭐⭐
- Чем адаптер отличается от прокси (Proxy)? В каких случаях прокси может выглядеть как адаптер и почему важно различать их намерение? ⭐⭐⭐
- Чем адаптер отличается от декоратора? Объясните разницу на уровне **контракта** и **намерения**.
  Приведите пример, где путаница приведёт к плохому дизайну. ⭐⭐⭐
- В каких ситуациях адаптер может «прятать» проблемы дизайна и откладывать рефакторинг, вместо того чтобы улучшать систему? ⭐⭐⭐
- Допустим, у вас есть несколько внешних библиотек с разными интерфейсами, но одинаковым смыслом.
  Как бы вы спроектировали систему адаптеров, чтобы клиентский код не зависел от конкретной библиотеки? ⭐⭐⭐
- Что делать, если адаптируемый интерфейс часто меняется (частые breaking changes)?
  Как организовать адаптеры и тесты, чтобы изменения локализовывались? ⭐⭐⭐
- Какие виды тестов наиболее важны для адаптера: модульные, контрактные, интеграционные?
  Что именно должен гарантировать тест адаптера? ⭐⭐
- Рассмотрите пример с ListView и `IListViewDataSource`. Почему это пример адаптера, даже если он выглядит как «просто интерфейс»?
  Где здесь Target и Adaptee? ⭐⭐⭐
- Почему вариант «передавать массив IListItemView» (готовые визуальные элементы) считается плохим решением?
  Объясните с точки зрения производительности, архитектуры и ответственности. ⭐⭐⭐
- Как адаптер в ListView помогает реализовать ленивое создание элементов (on-demand)?
  Какие преимущества это даёт? ⭐⭐
- Приведите пример адаптера для подключения клиента к нескольким TTS-сервисам.
  Какие интерфейсы вы бы сделали целевыми, и какие проблемы интеграции адаптер должен скрывать? ⭐⭐⭐
- Что такое **функциональный адаптер** (адаптация функции к другой сигнатуре/контракту)?
  Приведите пример преобразования входных данных и объясните, почему это тоже «Адаптер». ⭐⭐
- Приведите пример функционального адаптера, который превращает синхронную функцию в асинхронную (sync → async).
  Какие ограничения и гарантии должен соблюдать такой адаптер? ⭐⭐⭐
- Напишите адаптер, адаптирующий объекты `adaptee` к интерфейсам `target`. См. диаграмму классов:

  ```mermaid
  classDiagram
    namespace target {
      class IShape {
        <<interface>>
        GetStyle() IStyle&
      }

      class IStyle {
        <<interface>>
        GetColor() uint32
      }
    }

    namespace adaptee {
      class Shape {
        m_style: Style
        GetStyle() Style&
      }
      class Style {
        m_color: Color
        GetColor() Color
      }
      class Color {
        <<struct>>
        r: byte
        g: byte
        b: byte
        a: byte
      }
    }
    class Client {
    }

    IShape ..> IStyle
    Shape *-- Style
    Style *-- Color
    Client ..> IShape
    Client ..> IStyle
  ```

### Паттерн проектирования "Шаблонный метод"

- Объясните суть паттерна «Шаблонный метод» и сформулируйте, какой именно тип повторного использования он даёт. ⭐
- Почему «дублирование кода» часто является сигналом к архитектурным изменениям?
  Какие виды дублирования особенно опасны в OOP? ⭐⭐
- В «тривиальном решении» (когда `PrepareRecipe()` виртуальный/абстрактный и реализуется в каждом подклассе) какие проблемы появляются при изменении порядка шагов алгоритма?
  Объясните на уровне сопровождения и рисков регрессий. ⭐⭐
- Дайте определение «скелета алгоритма» в Template Method.
  Как отличить «скелет» от «деталей реализации» в реальном коде? ⭐⭐
- Почему в классическом Template Method базовый метод-шаблон (`PrepareRecipe`) часто делают **невиртуальным**? ⭐⭐
- Объясните разницу между **абстрактными шагами** (pure virtual) и **hooks** (виртуальные с реализацией по умолчанию).
  Приведите пример, когда hook лучше абстрактного метода. ⭐⭐
- Придумайте 2–3 разных типа hook’ов в шаблонном методе и поясните их влияние на расширяемость и читаемость. ⭐⭐
- В примере с `CustomerWantsCondiments()` какие риски вносит интерактивный ввод/IO в hook?
  Как бы вы тестировали такой код? ⭐⭐
- Как Template Method связан с Голливудским принципом («принцип инверсии управления»)?
  Опишите различие между *направлением зависимостей* и *направлением потока управления*. ⭐⭐
- Сравните DIP и Голливудский принцип: почему можно соблюдать один и нарушать другой? Приведите пример. ⭐⭐⭐
- Какие антипаттерны/запахи кода могут возникнуть при чрезмерном использовании Template Method? Как их распознать? ⭐⭐⭐
- Какие требования к контракту (pre/post conditions, инварианты) особенно важны в Template Method?
  Где их лучше фиксировать: в базовом методе или в шагах? Почему? ⭐⭐⭐
- Что такое идиома NVI (Non-Virtual Interface) и чем она отличается по фокусу от Template Method?
  В каких случаях NVI предпочтительнее? ⭐⭐
- Разберите пример `Document::Save()` (NVI): какие элементы “политики” централизованы в невиртуальном методе и почему это полезно для качества системы? ⭐⭐
- Почему сочетание `virtual` + default arguments в C++ опасно?
  Объясните механизм привязки значений по умолчанию и покажите, как NVI решает проблему. ⭐⭐⭐
- Какие шаги в Template Method стоит делать `private`, какие `protected`, а какие `public`?
  Обоснуйте с точки зрения инкапсуляции и защиты контракта. ⭐⭐
- Опишите типичные ошибки проектирования Template Method в C++: вызов виртуальных методов из конструктора/деструктора, “обходные” публичные виртуальные методы, нарушение инвариантов.
  Почему они опасны? ⭐⭐⭐
- Допустим, в шаблонном методе есть шаг, который должен быть выполнен *ровно один раз* (идемпотентность/инициализация).
  Где лучше хранить состояние и как избежать “частично инициализированного” объекта? ⭐⭐⭐
- Придумайте пример, где Template Method конфликтует с LSP (принцип подстановки Лисков).
  Что именно должен “сломать” подкласс, чтобы нарушить LSP? ⭐⭐⭐
- Как бы вы документировали точки расширения Template Method, чтобы избежать “магии фреймворка” и скрытых зависимостей порядка вызовов? ⭐⭐
- В каких ситуациях Template Method лучше заменить на Strategy? Сформулируйте критерии выбора. ⭐⭐
- Как Template Method соотносится с Factory Method? Приведите сценарий, когда Template Method вызывает фабричный метод на одном из шагов. ⭐⭐
- В примере “напитков” добавьте шаг “подогреть чашку” или “проверить наличие ингредиентов”. Куда вы его добавите и почему? ⭐⭐
- Опишите compile-time Template Method (CRTP): как переносится диспетчеризация из рантайма в компилятор?
  Какие требования предъявляются к Derived? ⭐⭐
- Какие ограничения CRTP-варианта критичны для архитектуры? Как бы вы смягчали эти ограничения? ⭐⭐⭐
- Почему “нестатические методы наследника нельзя вызывать из конструктора/деструктора родителя” особенно важно в CRTP-варианте?
  Приведите пример бага и способ избежать. ⭐⭐⭐
- Спроектируйте Template Method для Undo/Redo (команды): какие шаги должны быть инвариантными, а какие — вариативными? ⭐⭐⭐
- Приведите пример Template Method в UI/веб-фреймворке (pipeline обработки события/запроса).
  Какие hooks там обычно предоставляют, и какие риски создаёт неправильное использование hooks? ⭐⭐⭐
- Представьте, что вам нужно обеспечить единые политики для набора операций, где часть шагов вариативна.
  Как бы вы совместили Template Method и NVI так, чтобы подклассы не могли “обойти” политику? ⭐⭐⭐

### Паттерн проектирования "Итератор"

- Дайте описание паттерна
- Какие проблемы решает паттерн?
- Постройте диаграмму классов этого паттерна.
- Какие классы/интерфейсы участвуют в паттерне? Какую роль они играют?
- Какие у паттерна есть преимущества и недостатки?
- Приведите пример использования (нарисуйте диаграмму классов).
- Какие существуют альтернативы этому паттерну?
- Следованию каких принципов SOLID способствует применение паттерна?
- Какие ограничения есть у паттерна?
- Напишите пример кода, иллюстрирующий применение этого паттерна.

### Паттерн проектирования "Компоновщик"

- Дайте описание паттерна
- Какие проблемы решает паттерн?
- Постройте диаграмму классов этого паттерна.
- Какие классы/интерфейсы участвуют в паттерне? Какую роль они играют?
- Какие у паттерна есть преимущества и недостатки?
- Может ли в иерархии классов быть не один, а несколько классов-компоновщиков?
  Обоснуйте свой ответ.
- Может ли в иерархии классов
- Приведите пример использования (нарисуйте диаграмму классов).
- Как клиенты могут получить доступ к операциям составного объекта,
  имея изначально ссылку на базовый компонент?
- Какие существуют альтернативы этому паттерну?
- Следованию каких принципов SOLID способствует применение паттерна?
- Какие ограничения есть у паттерна?
- Напишите пример кода, иллюстрирующий применение этого паттерна.

### Паттерн проектирования "Состояние"

- Дайте описание паттерна
- Какие проблемы решает паттерн?
- Постройте диаграмму классов этого паттерна.
- Какие классы/интерфейсы участвуют в паттерне? Какую роль они играют?
- Какие у паттерна есть преимущества и недостатки?
- Приведите пример использования (нарисуйте диаграмму классов).
- Какие существуют альтернативы этому паттерну?
- Следованию каких принципов SOLID способствует применение паттерна?
- Какие ограничения есть у паттерна?
- Напишите пример кода, иллюстрирующий применение этого паттерна.
- Особенности реализации паттерна "Состояние" в языках, не поддерживающих приватное наследование.
- Кто инициирует переходы между состояниями в паттерне "Состояние"?

### Паттерн проектирования "Заместитель"

- Дайте описание паттерна
- Какие проблемы решает паттерн?
- Постройте диаграмму классов этого паттерна.
- Какие классы/интерфейсы участвуют в паттерне? Какую роль они играют?
- Какие существуют виды паттерна "Заместитель"? Постройте их диаграммы классов?
- Какие у паттерна есть преимущества и недостатки?
- Приведите пример использования (нарисуйте диаграмму классов).
- Какие существуют альтернативы этому паттерну?
- Следованию каких принципов SOLID способствует применение паттерна?
- Какие ограничения есть у паттерна?
- Напишите пример кода, иллюстрирующий применение этого паттерна.

### Паттерн проектирования "Посетитель"

- Дайте описание паттерна
- Какие проблемы решает паттерн?
- Постройте диаграмму классов этого паттерна.
- Какие классы/интерфейсы участвуют в паттерне? Какую роль они играют?
- Какие у паттерна есть преимущества и недостатки?
- Для чего применяется ациклический посетитель? Нарисуйте его диаграмму классов.
  Какие есть недостатки у этой версии паттерна?
- При использовании паттерна "Посетитель" возникает дублирование кода.
  Как можно уменьшить дублирование кода, используя шаблоны в C++?
- Приведите пример использования (нарисуйте диаграмму классов).
- Какие существуют альтернативы этому паттерну?
- Следованию каких принципов SOLID способствует применение паттерна?
- Какие ограничения есть у паттерна?
- Напишите пример кода, иллюстрирующий применение этого паттерна.

### Паттерн проектирования "Прототип"

- Дайте описание паттерна
- Какие проблемы решает паттерн?
- Постройте диаграмму классов этого паттерна.
- Какие классы/интерфейсы участвуют в паттерне? Какую роль они играют?
- Какие у паттерна есть преимущества и недостатки?
- Приведите пример использования (нарисуйте диаграмму классов).
- Какие существуют альтернативы этому паттерну?
- Следованию каких принципов SOLID способствует применение паттерна?
- Какие ограничения есть у паттерна?
- Напишите пример кода, иллюстрирующий применение этого паттерна.

### Паттерн проектирования "Строитель"

- Дайте описание паттерна
- Какие проблемы решает паттерн?
- Постройте диаграмму классов этого паттерна.
- Какие классы/интерфейсы участвуют в паттерне? Какую роль они играют?
- Какие у паттерна есть преимущества и недостатки?
- Приведите пример использования (нарисуйте диаграмму классов).
- Какие существуют альтернативы этому паттерну?
- Следованию каких принципов SOLID способствует применение паттерна?
- Какие ограничения есть у паттерна?
- Напишите пример кода, иллюстрирующий применение этого паттерна.

### Паттерн проектирования "Мост"

- Дайте описание паттерна
- Какие проблемы решает паттерн?
- Постройте диаграмму классов этого паттерна.
- Какие классы/интерфейсы участвуют в паттерне? Какую роль они играют?
- Какие у паттерна есть преимущества и недостатки?
- Приведите пример использования (нарисуйте диаграмму классов).
- Какие существуют альтернативы этому паттерну?
- Следованию каких принципов SOLID способствует применение паттерна?
- Какие ограничения есть у паттерна?
- Напишите пример кода, иллюстрирующий применение этого паттерна.

### Архитектура GUI-приложений. Document-View

- Достоинства и недостатки подхода Smart UI.
- Из каких ключевых компонентов состоит приложение, использующее подход Document-View? За что отвечают эти компоненты?
- Постройте диаграмму классов приложения, использующего этот подход.
- Какие паттерны проектирования лежат в основе Document-View?
- Достоинства и недостатки подхода Document-View.
- Каким образом происходит обновление представления при изменении документа?
- Каким образом действия пользователя в одном представлении могут привести к обновлению других представлений этого документа?
- Напишите приложение, построенное с помощью подхода Document-View. Приложение должно отображать в окне сумму двух целых чисел, которые пользователь ввёл в поля ввода в окне. Сумма обновляется всякий раз, когда пользователь обновил содержимое поля ввода.

### Архитектура GUI-приложений. Model-View-Controller

- Достоинства и недостатки подхода Smart UI.
- Из каких ключевых компонентов состоит приложение, использующее подход Model-View-Controller? За что отвечают эти компоненты?
- Постройте диаграмму классов приложения, использующего этот подход.
- Какие паттерны проектирования лежат в основе Model-View-Controller?
- Достоинства и недостатки подхода Model-View-Controller.
- Каковы сходства и отличия подходов MVC и Document-View.
- Напишите приложение, построенное с помощью подхода Model-View-Controller. Приложение должно отображать в окне сумму двух целых чисел, которые пользователь ввёл в поля ввода в окне. Сумма обновляется всякий раз, когда пользователь обновил содержимое поля ввода.

### Архитектура GUI-приложений. Model-View-Presenter

- Достоинства и недостатки подхода Smart UI.
- Из каких ключевых компонентов состоит приложение, использующее подход Model-View-Presenter? За что отвечают эти компоненты?
- Постройте диаграмму классов приложения, использующего этот подход.
- Какие паттерны проектирования лежат в основе Model-View-Presenter?
- Достоинства и недостатки подхода Model-View-Presenter.
- Каковы сходства и отличия подходов MVP и MVC.
- Напишите приложение, построенное с помощью подхода Model-View-Presenter. Приложение должно отображать в окне сумму двух целых чисел, которые пользователь ввёл в поля ввода в окне. Сумма обновляется всякий раз, когда пользователь обновил содержимое поля ввода.

## Принципы проектирования ПО

### Отношения между классами

- Визуализация структуры программы на диаграмме классов.
  - Как обозначаются классы на диаграмме классов?
  - Как обозначаются абстрактные классы?
  - Как обозначить видимость методов и данных на диаграмме классов?
  - Как обозначаются статические методы и данные на диаграмме классов?
  - Как обозначаются абстрактные методы?
- Композиция.
  - Что такое композиция?
  - Когда возникает отношение композиции между классами?
  - Обозначение композиции на диаграмме классов.
  - Приведите пример использования композиции в реальной программе.
  - Сокрытие данных при композиции.
- Агрегация
  - Что такое агрегация?
  - Когда возникает отношение агрегации?
  - Обозначение агрегации на диаграмме классов.
  - Сокрытие данных при агрегировании.
  - Приведите пример агрегации в реальной программе.
  - Отличие агрегации и композиции.
- Зависимость
  - Что такое зависимость?
  - Когда возникает отношение зависимости между классами?
  - Обозначение зависимости на диаграмме классов.
  - Что такое транзитивность зависимостей?
  - Приведите пример зависимости в реальной программе.
- Наследование
  - Что такое наследование? Какое отношение между классами существует при наследовании?
  - Как наследование обозначается на диаграмме классов?
- Интерфейсы
  - Как отображаются интерфейсы на диаграмме классов.
  - Каким отношениями могут и не могут быть связаны интерфейсы с другими программными сущностями?
  - Как на диаграмме классов обозначается класс, реализующий интерфейс?
  - Может ли один интерфейс быть унаследован от другого?

### Принцип единственной ответственности (SRP)

- В чём заключается Принцип Единственной Ответственности?
- Приведите пример нарушения SRP на диаграмме классов. Выполните рефакторинг, чтобы соблюсти SRP.
- Какие выгоды от следования принципу SRP? Обоснуйте свой ответ.
- Как соблюдение и нарушение SRP влияет на поддерживаемость кода? Обоснуйте свой ответ.
- Каким образом нужно проектировать программу, чтобы соблюсти этот принцип?
- Как соблюдение и нарушение SRP влияет на тестируемость кода? Обоснуйте свой ответ.
- Выразите своё отношение к следующим утверждениям:
  - Согласно SRP класс должен иметь только один метод.
  - SRP имеет смысл применять только в больших проектах.
  - Следование SRP приводит к чрезмерному количеству классов.
  - В соответствии с SRP у класса должна быть ровно одна зона ответственности.
  - Принцип единственной ответственности применим только в объектно-ориентированных программах.

### Принцип открытости-закрытости (OCP)

- В чём заключается принцип открытости-закрытости?
- В чём важность этого принципа в архитектуре ПО?
- Приведите пример нарушения OCP на диаграмме классов. Какие недостатки имеет архитектура программы? Выполните рефакторинг так, чтобы архитектура следовала этому принципу.
- Какая практическая польза от следования принципу открытости-закрытости? Обоснуйте свой ответ.
- Каким образом нужно проектировать программу, чтобы соблюсти этот принцип?
- Как соблюдение и нарушение OCP влияет на легкость поддержки кода? Обоснуйте свой ответ.
- Как соблюдение и нарушение OCP влияет на легкость тестирования? Обоснуйте свой ответ.
- Какие паттерны проектирования помогают соблюдать этот принцип?
- Выразите своё отношение к следующим утверждениям:
  - Следование OCP означает, что не нужно никогда вносить изменения в существующий код.
  - Принцип открытости-закрытости применим только в объектно-ориентированных программах.
  - Следование OCP приводит к излишней сложности кода.
  - OCP имеет смысл применять только в больших программах.

### Принцип подстановки Лисков (LSP)

- В чём заключается принцип подстановки Лисков?
- Почему этот принцип важен в архитектуре ПО?
- Приведите примеры нарушения LSP.
- Каким образом нужно проектировать программу, чтобы соблюсти этот принцип?
- Что такое ковариантность и контрвариантность и как они связаны с этим принципом?
- Как автоматически протестировать соблюдение LPS?
- Как обнаружить нарушение этого принципа при ревью кода?
- Каковы последствия нарушения принципа LSP?

### Принцип разделения интерфейса (ISP)

- В чём заключается Принцип Разделения Интерфейса?
- Как этот принцип связан с принципом единственной ответственности?
- Приведите пример нарушения ISP на диаграмме классов. Какой рефакторинг вы бы провели, чтобы соблюсти принцип ISP.
- Как нарушение ISP влияет на легкость тестирования и поддержки кода? Обоснуйте свой ответ.
- Каким образом нужно проектировать программу, чтобы соблюсти этот принцип?
- Представьте, что вы проводите ревью кода. Как вы определите, нарушает ли код принцип разделения интерфейса?
- Как принцип этот принцип связан с принципом инверсии зависимостей?
- Выразите своё отношение к утверждениям:
  - В соответствии ISP каждый метод должен быть выделен в отдельный интерфейс.
  - ISP может быть применён только в объектно-ориентированных программах.
  - Следование ISP приводит к чрезмерному количеству интерфейсов.
  - ISP имеет смысл применять только в больших проектах.

### Принцип инверсии зависимостей (DIP)

- В чём заключается принцип инверсии зависимостей?
- В чём важность принципа инверсии зависимостей в архитектуре ПО?
- Приведите пример нарушения DIP на диаграмме классов. Проведите рефакторинг, чтобы соблюсти этот принцип.
- Каким образом нужно проектировать программу, чтобы соблюсти этот принцип?
- Какие паттерны проектирования помогают соблюдать DIP?
- Каковы последствия от нарушения DIP? Обоснуйте свой ответ.
- Как следование DIP влияет на легкость тестирования и поддержки кода?
- Приведите пример использования DIP в реальном приложении.

### Компоненты и их сочетаемость

- В чём отличие связности (Cohesion) и сцепленность (Coupling)?
- О чём говорит принцип "High Cohesion, Low Coupling"?
- Что такое устойчивость компонента?
- Метрики устойчивости компонента. Как вычислить неустойчивость компонента?
- В чём заключается принцип устойчивых зависимостей (SDP)?
- Определите устойчивость компонентов и нарушение/соблюдение принципа устойчивых зависимостей по диаграмме классов.
- Как исправить нарушение SDP?
- В чём заключается принцип устойчивости абстракций (SAP)?
- Метрики абстрактности компонента. Как вычислить меру абстрактности компонента?
- Диаграмма устойчивости/абстрактности компонентов. Отобразить компонент на диаграмме устойчивости/абстрактности.
- Ключевые зоны диаграммы: зона боли, зона бесполезности, главная последовательность.
- Как вычислить расстояние до главной последовательности?
