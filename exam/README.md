# Вопросы к экзамену

- [Вопросы к экзамену](#вопросы-к-экзамену)
  - [Паттерны проектирования](#паттерны-проектирования)
    - [Паттерн проектирования "Стратегия"](#паттерн-проектирования-стратегия)
    - [Паттерн проектирования "Наблюдатель"](#паттерн-проектирования-наблюдатель)
    - [Паттерн проектирования "Декоратор"](#паттерн-проектирования-декоратор)
    - [Паттерн проектирования "Абстрактная фабрика"](#паттерн-проектирования-абстрактная-фабрика)
    - [Паттерн проектирования "Фабричный метод"](#паттерн-проектирования-фабричный-метод)
    - [Паттерны проектирования "Команда" и "Хранитель"](#паттерны-проектирования-команда-и-хранитель)
    - [Паттерн проектирования "Адаптер"](#паттерн-проектирования-адаптер)
    - [Паттерн проектирования "Шаблонный метод"](#паттерн-проектирования-шаблонный-метод)
    - [Паттерн проектирования "Итератор"](#паттерн-проектирования-итератор)
    - [Паттерн проектирования "Компоновщик"](#паттерн-проектирования-компоновщик)
    - [Паттерн проектирования "Состояние"](#паттерн-проектирования-состояние)
    - [Паттерн проектирования "Заместитель"](#паттерн-проектирования-заместитель)
    - [Паттерн проектирования "Посетитель"](#паттерн-проектирования-посетитель)
    - [Паттерн проектирования "Прототип"](#паттерн-проектирования-прототип)
    - [Паттерн проектирования "Строитель"](#паттерн-проектирования-строитель)
    - [Паттерн проектирования "Мост"](#паттерн-проектирования-мост)
    - [Архитектура GUI-приложений. Document-View](#архитектура-gui-приложений-document-view)
    - [Архитектура GUI-приложений. Model-View-Controller](#архитектура-gui-приложений-model-view-controller)
    - [Архитектура GUI-приложений. Model-View-Presenter](#архитектура-gui-приложений-model-view-presenter)
  - [Принципы проектирования ПО](#принципы-проектирования-по)
    - [Отношения между классами](#отношения-между-классами)
    - [Принцип единственной ответственности (SRP)](#принцип-единственной-ответственности-srp)
    - [Принцип открытости-закрытости (OCP)](#принцип-открытости-закрытости-ocp)
    - [Принцип подстановки Лисков (LSP)](#принцип-подстановки-лисков-lsp)
    - [Принцип разделения интерфейса (ISP)](#принцип-разделения-интерфейса-isp)
    - [Принцип инверсии зависимостей (DIP)](#принцип-инверсии-зависимостей-dip)
    - [Domain-Driven Design - 1](#domain-driven-design---1)
    - [Domain-Driven Design - 2](#domain-driven-design---2)

## Паттерны проектирования

### Паттерн проектирования "Стратегия"

- В чём принципиальная разница между умением писать код и умением проектировать систему?
   ⭐⭐
- Почему требования к программным системам почти всегда изменяются, и как это влияет на выбор архитектуры?
   ⭐⭐
- Почему паттерны проектирования не являются «готовыми решениями»?
   ⭐
- Как паттерн «Стратегия» помогает избежать велосипедостроения?
   ⭐⭐
- В каких ситуациях применение паттерна «Стратегия» может быть избыточным или вредным? Приведите пример.
   ⭐⭐⭐
- Какие архитектурные проблемы проявились в начальной реализации «утиного симулятора» при добавлении `Fly()`?
   ⭐⭐
- Почему «локальное изменение кода привело к нелокальным эффектам» — особенно опасная ситуация в командной разработке?
   ⭐⭐
- Почему переопределение `Fly()` и `Quack()` в подклассах плохо масштабируется?
   ⭐⭐
- Какие проблемы в примере с утками относятся к нарушению SRP, а какие — к нарушению OCP?
   ⭐⭐⭐
- Что такое «хрупкий базовый класс» и почему это фундаментальная проблема ООП?
    ⭐⭐⭐
- Почему решение с интерфейсами `Flyable` / `Quackable` и `dynamic_cast` считается архитектурно слабым?
    ⭐⭐
- По каким признакам в существующем коде можно понять, что пора заменить наследование композицией?
    ⭐⭐⭐
- Почему принцип «отделяйте изменяемое от неизменяемого» является ключевым для стратегии?
    ⭐⭐
- Как независимость изменений полёта и кряканья влияет на структуру классов?
    ⭐⭐
- Как принцип *Program to an interface, not an implementation* реально снижает стоимость изменений?
    ⭐⭐⭐
- Дайте развёрнутое определение паттерна «Стратегия» и опишите роли Контекста и Стратегии.
    ⭐⭐
- Почему делегирование поведения снижает связанность системы?
    ⭐⭐
- Какие преимущества и риски даёт динамическая смена стратегии в рантайме?
    ⭐⭐
- В каких случаях Контекст стоит делать интерфейсом, а в каких — конкретным классом?
    ⭐⭐⭐
- Почему возможность переиспользования стратегий другими объектами — признак хорошей абстракции?
    ⭐⭐⭐
- Могут ли стратегии иметь собственное состояние?
    ⭐
- Когда наличие состояния в стратегии — оправданное решение, а когда — симптом вырождающейся архитектуры?
    ⭐⭐⭐
- В чём разница между хранением состояния в Контексте и в Стратегии?
    ⭐⭐
- Почему попытка «хранить всё состояние в Контексте» может привести к плохому дизайну?
    ⭐⭐⭐
- Как принципы YAGNI и KISS влияют на решение о добавлении состояния в стратегию?
    ⭐⭐⭐
- Что означает `const`-метод в интерфейсе стратегии с точки зрения контракта?
    ⭐⭐
- Почему опасно объявлять командные методы стратегии `const`, даже если реализация «умеет» это обойти?
    ⭐⭐⭐
- Как LSP и CQS ограничивают проектирование интерфейсов стратегий в C++?
    ⭐⭐⭐
- В каких случаях допустима логическая константность (`mutable`), и какие архитектурные риски она несёт?
    ⭐⭐⭐
- Кто должен определять интерфейс стратегии — разработчик Контекста или разработчик стратегий? Почему?
    ⭐⭐⭐

### Паттерн проектирования "Наблюдатель"

- Дайте определение паттерна проектирования «Наблюдатель» и опишите проблему, которую он решает. ⭐
- Какие роли выделяются в паттерне «Наблюдатель» и какова ответственность каждой из них? ⭐
- Что означает отношение «один-ко-многим» в контексте паттерна «Наблюдатель»? ⭐
- Приведите пример использования паттерна «Наблюдатель» из реальной жизни, не связанный с программированием. ⭐
- Почему паттерн «Наблюдатель» относят к поведенческим паттернам? ⭐
- В чем заключается основная проблема наивной реализации обновления зависимых объектов (на примере WeatherData)? ⭐⭐
- Почему привязка субъекта к конкретным классам наблюдателей считается плохим архитектурным решением? ⭐⭐
- Какие принципы SOLID нарушаются в наивной реализации WeatherData и почему? ⭐⭐
- Объясните, что означает «инкапсуляция переменной части» и как паттерн «Наблюдатель» помогает её достичь. ⭐⭐
- Почему введение общего интерфейса наблюдателя является ключевым шагом при применении паттерна? ⭐⭐
- В чем состоит идея слабой связанности (loose coupling) и как паттерн «Наблюдатель» её обеспечивает? ⭐⭐
- Опишите жизненный цикл наблюдателя: регистрация, получение уведомлений, отписка. ⭐⭐
- В каких случаях имеет смысл динамически добавлять и удалять наблюдателей во время выполнения программы? ⭐⭐
- Чем модель вытягивания (pull model) отличается от модели проталкивания (push model)? ⭐⭐
- Какие преимущества и недостатки у pull-модели в сравнении с push-моделью? ⭐⭐
- Как реализовать подписку наблюдателей только на интересующие их изменения состояния субъекта? ⭐⭐⭐
- Какие проблемы могут возникнуть, если наблюдатель наблюдает более чем за одним субъектом, и как их решать? ⭐⭐⭐
- Почему важно, чтобы субъект находился в согласованном состоянии перед оповещением наблюдателей? ⭐⭐⭐
- Как паттерн «Шаблонный метод» может использоваться совместно с паттерном «Наблюдатель»? ⭐⭐⭐
- Кто должен инициировать оповещение наблюдателей — субъект или клиент — и какие компромиссы есть у каждого подхода? ⭐⭐⭐
- Какие дополнительные сложности возникают при реализации паттерна «Наблюдатель» в языках без сборщика мусора? ⭐⭐⭐
- Что такое «висячие ссылки» в контексте паттерна «Наблюдатель» и как их избежать? ⭐⭐⭐
- Допустимо ли, чтобы метод Update у наблюдателя возвращал значение, и как это может повлиять на поведение субъекта? ⭐⭐⭐
- В каких случаях наблюдателям разрешается изменять состояние субъекта, и какие риски это несет? ⭐⭐⭐
- Как обеспечить расширяемость системы, не модифицируя код субъекта при добавлении новых типов наблюдателей? ⭐⭐⭐
- В чем отличие классической объектно-ориентированной реализации паттерна от функционального варианта с callback-функциями? ⭐⭐⭐
- Какие преимущества дает использование библиотек сигналов и слотов (например, boost::signals2) по сравнению с ручной реализацией Observer? ⭐⭐⭐
- Как паттерн «Наблюдатель» соотносится с принципом «программируй на уровне интерфейсов, а не реализаций»? ⭐⭐⭐
- В каких ситуациях использование паттерна «Наблюдатель» может привести к ухудшению архитектуры или производительности? ⭐⭐⭐
- Как Наблюдатель может указать, в каких обновлениях он заинтересован? ⭐⭐⭐
- Может ли Субъект выступать в роли Наблюдателя? Может ли Наблюдатель выступать в роли Субъекта? Приведите примеры. ⭐⭐

### Паттерн проектирования "Декоратор"

- Объясните, какую проблему решает паттерн «Декоратор» и почему попытка решить её только наследованием приводит к «комбинаторному взрыву» классов. ⭐⭐
- В чём ключевое отличие «расширения поведения» через декоратор от «расширения поведения» через наследование? Приведите пример из домена «кофейня». ⭐⭐
- Опишите роли участников паттерна Decorator (Component, ConcreteComponent, Decorator, ConcreteDecorator) и сопоставьте их с вашими классами напитков/добавок. ⭐⭐
- Почему важно, что декоратор имеет тот же тип (реализует тот же интерфейс), что и декорируемый объект? Как это связано с полиморфизмом и LSP? ⭐⭐
- Объясните, как в цепочке декораторов вычисляется стоимость напитка (по шагам), и какие гарантии корректности даёт такая структура. ⭐
- Какие признаки подсказывают, что в задаче следует применить декоратор, а не просто добавить методы в базовый класс? ⭐⭐
- Сравните подход «флаги в базовом классе» и подход «декораторы»: какие риски и ограничения есть у каждого, и почему флаги нарушают OCP? ⭐⭐
- Какие «странные комбинации» появляются при реализации через флаги? Как в декораторе можно ограничивать/валидировать недопустимые комбинации? ⭐⭐⭐
- Объясните принцип Open/Closed (OCP) на примере добавления новой добавки (например, «ванильный сироп»): что нужно менять в варианте с флагами и что — в варианте с декоратором? ⭐⭐
- Почему композиция считается более гибкой, чем наследование, в контексте динамического добавления поведения? Приведите пример «во время выполнения». ⭐⭐
- Какие недостатки могут появиться у декоратора по сравнению с наследованием (производительность, отладка, сложность), и как их обычно смягчают? ⭐⭐⭐
- В каких случаях использование декоратора будет избыточным? Назовите критерии и приведите пример. ⭐⭐
- Чем декоратор отличается от прокси и адаптера, если внешне они могут выглядеть похоже (обёртка вокруг объекта)? ⭐⭐⭐
- Почему в `CondimentDecorator` методы `GetDescription()` и `GetCost()` целесообразно сделать `final`? Какие проблемы возникнут, если их разрешить переопределять? ⭐⭐⭐
- Объясните, как в `CondimentDecorator` проявляется паттерн «Шаблонный метод»: где «скелет алгоритма», а где «шаги, делегируемые подклассам»? ⭐⭐
- Почему «шаги алгоритма» (`GetCondimentCost`, `GetCondimentDescription`) можно сделать `private virtual`? Какие архитектурные преимущества это даёт? ⭐⭐⭐
- Как бы вы реализовали «двойную порцию шоколада» в модели с декораторами? Приведите минимум два подхода и сравните их. ⭐⭐
- Какие требования к владению объектом и управлению временем жизни возникают при реализации декоратора? Почему в примере используется `unique_ptr`? ⭐⭐
- Что изменится, если вместо `unique_ptr` использовать `shared_ptr`? Какие новые риски и возможности это создаст для цепочек декораторов? ⭐⭐⭐
- Как декоратор влияет на тестируемость системы? Опишите стратегию юнит-тестирования для базового напитка и для конкретной добавки-декоратора. ⭐⭐
- Как можно реализовать «снятие декорации» (unwrap) или интроспекцию цепочки декораторов, не нарушая инкапсуляцию? ⭐⭐⭐
- Какие ошибки проектирования часто допускают при внедрении декоратора (например, «захардкодить цены в одном месте», «слишком много обязанностей»)? Как их избежать? ⭐⭐⭐
- В примере со строками `StringTransformer` играет роль «интерфейса компонента». Какие свойства должны быть у такого интерфейса, чтобы декораторы хорошо композировались? ⭐⭐
- Почему ручная комбинация преобразователей строк (функции типа `UpperCaseWithSquareBrackets`) приводит к той же проблеме, что и наследование в примере кофейни? ⭐⭐
- Объясните, что делает функция `Decorate(t, d)` в функциональном стиле и как она связана с идеей «оборачивания» в ООП-декораторе. ⭐⭐
- В `Decorate` используется перемещение и `forward`. Какие проблемы с производительностью/корректностью решает perfect forwarding в таком коде? ⭐⭐⭐
- Какой смысл несёт «синтаксический сахар» (например, оператор `|` для строковых декораторов или `<<` для напитков)? Какие риски он несёт для читаемости и поддержки? ⭐⭐
- Приведите пример из реальной разработки, где декоратор используется повсеместно (например, middleware, I/O streams).
  Объясните, как там устроена «цепочка» и что именно добавляют декораторы. ⭐⭐
- Предложите дизайн декоратора для HTTP-клиента, который добавляет авторизацию, логирование и кэширование.
  Как вы определите порядок декораторов и почему? ⭐⭐⭐
- Представьте, что нужно добавить новое требование: «некоторые добавки конфликтуют друг с другом» и «цены зависят от времени суток».
  Как бы вы расширили решение на декораторах? ⭐⭐⭐

### Паттерн проектирования "Абстрактная фабрика"

- Объясните, какую проблему «Абстрактная фабрика» решает лучше, чем «простая фабрика» и «фабричный метод». ⭐⭐
- Что именно скрывает от клиента абстрактная фабрика кроме конкретных классов продуктов? ⭐⭐
- Как «Абстрактная фабрика» помогает соблюдать DIP? Опишите зависимости «до» и «после». ⭐⭐
- Что считается «семейством продуктов» и почему важно создавать их согласованно? ⭐⭐
- В каких случаях абстрактная фабрика превращается в God Factory и как это распознать по симптомам в коде? ⭐⭐
- Опишите стратегию тестирования кода, который использует абстрактную фабрику: что мокается и что проверяется? ⭐⭐
- Почему «неполные семейства» (часть create* не реализована) — архитектурная проблема?
  Какие варианты дизайна решают её? ⭐⭐⭐
- Как добавление нового продукта в семейство (новый метод `CreateX`) влияет на существующий код?
  Как минимизировать ущерб? ⭐⭐⭐
- Когда вместо абстрактной фабрики лучше применить Builder? Опишите критерии выбора. ⭐⭐
- Приведите пример «протекающей абстракции» при использовании абстрактной фабрики и объясните, что это означает. ⭐⭐⭐
- Как организовать выбор конкретной фабрики (NY vs Chicago) так, чтобы бизнес-код не знал о регионах/платформах? ⭐⭐⭐
- Чем опасна фабрика-синглтон с глобальным состоянием в контексте абстрактной фабрики? ⭐⭐
- Как абстрактная фабрика помогает «прибить» совместимость ингредиентов (NY-соус + NY-сыр)?
  Почему это сложно обеспечить без неё? ⭐⭐
- Опишите вариант реализации фабрики в функциональном стиле (через функции/лямбды). Когда это оправдано? ⭐⭐
- Какие параметры допустимо передавать в `IUIFactory::CreateLabel` и какие — недопустимо, и почему? ⭐⭐
- Предложите дизайн API фабрики UI-элементов так, чтобы клиент не передавал платформенные хендлы. ⭐⭐⭐
- Что такое composition root и почему он важен при работе с абстрактными фабриками? ⭐⭐
- Чем «фабрика фабрик» отличается от корректного выбора семейства через composition root? ⭐⭐⭐
- Как бы вы реализовали переключение семейства по feature-flag без протекания деталей в домен? ⭐⭐⭐
- В каких ситуациях допустимо держать в фабрике кэш и состояние? Когда это превращается в проблему? ⭐⭐⭐
- Объясните, как абстрактная фабрика помогает снижать стоимость изменения сигнатур конструкторов продуктов. ⭐⭐
- Какие риски создаёт использование строковых ключей для выбора конкретного продукта внутри фабрики? Чем заменить? ⭐⭐
- Как организовать регистрацию продуктов/креаторов в фабрике, чтобы добавление новых типов не требовало редактирования `if/else`? ⭐⭐
- Приведите пример, когда абстрактная фабрика не нужна, и её использование ухудшит дизайн (YAGNI). ⭐⭐
- Какие признаки того, что вы неправильно выбрали «ось вариативности» и вам нужен другой паттерн (Strategy/Bridge/DI)? ⭐⭐⭐
- Опишите компромисс: «больше интерфейсов и классов» vs «гарантированная совместимость».
  Как бы вы аргументировали решение команде? ⭐⭐⭐
- Как обеспечить, чтобы продукты одного семейства не создавали напрямую продукты другого семейства? ⭐⭐⭐
- Как связать абстрактную фабрику с фабричным методом в одном решении? ⭐⭐

### Паттерн проектирования "Фабричный метод"

- Сформулируйте идею паттерна «Фабричный метод» своими словами и объясните, где в PizzaStore он проявляется. ⭐
- Почему фабричный метод часто сочетается с шаблонным методом? Что фиксируется, а что вариативно? ⭐⭐
- Какие зависимости убирает фабричный метод по сравнению с прямым созданием (`new`/`make_unique`) в клиенте? ⭐⭐
- Как фабричный метод помогает соблюдать OCP на примере расширения ассортимента пиццы? ⭐⭐
- В чём различие между «простая фабрика» и «фабричный метод» на уровне расширяемости и наследования? ⭐⭐
- Опишите параметризованный фабричный метод и его типичные проблемы. Как их лечить? ⭐⭐
- Опишите непараметризованный фабричный метод. В каких сценариях он предпочтительнее? ⭐⭐
- Почему «параллельные иерархии классов» считаются недостатком FactoryMethod и когда это оправдано? ⭐⭐⭐
- Как избежать комбинаторного взрыва, если фабричных методов несколько и продуктов много? ⭐⭐⭐
- Какие есть способы ограничить переопределение алгоритма конструирования объекта в базовом классе? ⭐⭐
- Объясните, почему ошибка типа «забыли вызвать `Pizza::Cut()`» — системная проблема дизайна,
  а не баг конкретного разработчика. ⭐⭐
- Какая часть кода должна оставаться в базовом классе Creator, а какая — в подклассах? Назовите критерии. ⭐⭐
- Как фабричный метод соотносится с DIP: кто от кого должен зависеть? ⭐⭐
- Почему использование строковых параметров (`type == "cheese"`) — риск? Предложите улучшение API. ⭐⭐
- Какие варианты обработки ошибок создания продукта вы предложите (исключения/Optional/Result)
  и как это влияет на дизайн Creator? ⭐⭐⭐
- Как тестировать базовый алгоритм Creator независимо от конкретных продуктов? ⭐⭐
- Как тестировать конкретный подкласс Creator так, чтобы не дублировать тесты базового алгоритма? ⭐⭐⭐
- Когда FM превращается в анти-паттерн: «переабстракция на вырост»? Приведите признаки. ⭐⭐
- Как выглядит «протекающая абстракция» в FM и как её исправить (когда клиент всё равно знает ConcreteProduct)? ⭐⭐⭐
- В чём смысл требования: «Creator не должен делать предположений о конкретном типе продукта»?
  Как это нарушается на практике? ⭐⭐⭐
- Как бы вы рефакторили код DependentPizzaStore, чтобы применить фабричный метод и уменьшить зависимости? ⭐⭐
- Что изменится в проекте при добавлении новой пиццы и нового региона при использовании FM? Сравните с подходом без FM. ⭐⭐⭐
- Как выбрать между FM и Strategy для задачи «выбор типа создаваемого объекта во время выполнения»? ⭐⭐⭐
- Какие компромиссы возникают при попытке сделать фабричный метод статическим? ⭐⭐
- Как фабричный метод влияет на способность кэшировать/переиспользовать продукты или их части? ⭐⭐⭐
- В C++: какие вопросы владения ресурсами (unique_ptr/shared_ptr) особенно важны при реализации FM? ⭐⭐
- Как обеспечить, что разные подклассы Creator не нарушат инварианты продукта (например, обязательные шаги подготовки)? ⭐⭐⭐
- Приведите пример, где FM лучше заменить на Abstract Factory, и объясните, почему FM не справляется. ⭐⭐⭐

### Паттерны проектирования "Команда" и "Хранитель"

- Объясните, какую архитектурную проблему решает паттерн **Command** и почему прямой вызов методов получателя из UI считается плохим решением. ⭐
- В чём различие ролей **Client**, **Invoker**, **Command**, **Receiver**? Приведите пример для каждого участника из системы “меню → робот”. ⭐
- Почему **инициатор (Invoker)** не должен создавать команды? Какие зависимости возникнут, если он будет знать конкретные классы команд? ⭐⭐
- Какие преимущества даёт то, что запрос представлен объектом (Command), а не вызовом метода? Назовите минимум 3 практических эффекта. ⭐
- Что именно должно храниться внутри объекта команды: получатель, параметры, логика, состояние? Обоснуйте распределение ответственности. ⭐⭐
- Объясните, что означает “ослабление связности” в контексте Command. Какая связность уменьшается и какие зависимости остаются? ⭐⭐
- Как паттерн Command помогает реализовать **конфигурирование действий** (например, связывание фраз с командами в меню)? ⭐
- Как бы вы расширили пример с роботом, чтобы добавить команду “идти 10 секунд”, не меняя код меню? Какие параметры и где вы бы хранили? ⭐⭐
- В каких случаях команда может быть реализована не классом, а **функциональным объектом** (`std::function`, лямбда)? Какие плюсы и минусы у такого подхода? ⭐⭐
- Как изменится тестируемость системы при переходе от прямых вызовов к Command? Какие части станет легче мокать и проверять? ⭐⭐
- Опишите архитектуру **Undo/Redo** на базе Command: какие структуры данных нужны и какие операции выполняются при Undo и Redo. ⭐⭐
- Почему не каждая операция естественно обратима? Приведите примеры команд, для которых сложно или дорого реализовать `Unexecute()`. ⭐⭐
- Объясните, как реализовать **макрокоманду** с возможностью отката изменений? ⭐⭐
- Что такое **макрокоманда** и какие паттерны в ней сочетаются? ⭐⭐
- Как бы вы реализовали макрокоманду так, чтобы при ошибке в середине выполнения система оставалась в консистентном состоянии? ⭐⭐⭐
- В чём проблема “избыточной истории изменений” в редакторах и почему она ухудшает UX Undo/Redo? ⭐
- Объясните идею **склеивания (coalescing)** соседних команд редактирования. По каким признакам можно понять, что команды нужно объединить? ⭐⭐
- Чем отличаются стратегии `AddEdit()` и `ReplaceEdit()` при работе с историей изменений в примере из лекции?
  В каких случаях полезна каждая из них? ⭐⭐
- В примере `EditText::ReplaceEditImpl()` используется сравнение `otherEditText->m_newText == m_oldText`.
  Почему это важная проверка и какую семантику она выражает? ⭐⭐⭐
- Какие риски появляются при “умных командах”, которые пытаются оптимизировать историю (например, склеивание)?
  Как это может повлиять на корректность Undo/Redo? ⭐⭐⭐
- Опишите две крайности “интеллектуальности команд” и объясните, почему они вредны с точки зрения принципов ООП и SOLID. ⭐⭐
- Где должна находиться бизнес-логика: в команде или в получателе? Приведите критерии принятия решения. ⭐⭐
- Какие дополнительные возможности появляются, если команды можно **сериализовать и десериализовать**?
  Какие ограничения это накладывает на дизайн команд? ⭐⭐⭐
- Как реализовать асинхронное выполнение команд (очередь задач, выполнение в другом потоке)? ⭐⭐⭐
- Чем Command-подход к Undo/Redo отличается от подхода “сохранить снимок состояния”? В каких случаях Command выгоднее? ⭐⭐
- Сформулируйте идею паттерна **Memento** и объясните, как он сохраняет инкапсуляцию. ⭐⭐
- Опишите роли **Originator**, **Memento**, **Caretaker** и их взаимодействие. Кто имеет право читать/изменять состояние? ⭐⭐
- Почему “классическая версия” Memento может потенциально нарушать инкапсуляцию, и как “альтернативная версия” решает эту проблему? ⭐⭐⭐
- В каких случаях Memento может быть слишком дорогим по памяти? Какие оптимизации можно применить? ⭐⭐⭐
- Спроектируйте систему Undo/Redo для редактора, где часть операций реализована через Command, а часть — через Memento.
  Как бы вы комбинировали их и почему? ⭐⭐⭐

### Паттерн проектирования "Адаптер"

- Объясните паттерн «Адаптер» своими словами и приведите **пример из промышленной разработки**, где он является наиболее уместным решением. ⭐
- Почему изменение интерфейса внешней библиотеки часто приводит к «поломке» системы? Какие свойства архитектуры делают систему особенно уязвимой к таким изменениям? ⭐⭐
- В каких ситуациях **переписывание клиентского кода** является плохой альтернативой адаптеру? Оцените это с точки зрения стоимости сопровождения и рисков. ⭐⭐
- Опишите роли **Client / Target / Adapter / Adaptee** и объясните, какие зависимости между ними допустимы, а какие являются архитектурной ошибкой. ⭐⭐
- Почему клиент «не должен знать про наличие адаптера»? Какие проблемы возникнут, если клиент начнёт зависеть от конкретного адаптера? ⭐⭐
- Рассмотрите пример «утки и индюшки». Какие именно несовместимости интерфейсов присутствуют в этом примере и как адаптер их устраняет? ⭐
- В примере с утками метод `Fly()` адаптера вызывает `Fly()` индюшки 5 раз. Почему это важно с точки зрения **семантической адаптации**, а не только совпадения сигнатур? ⭐⭐
- Что произойдёт, если адаптер будет реализован формально (методы совпадают), но **семантика поведения** не соответствует ожиданиям клиента? Приведите пример ошибки проектирования. ⭐⭐
- Объясните разницу между **объектным адаптером** и **классовым адаптером**. Когда вы выберете один подход вместо другого? ⭐⭐
- Какой адаптер обычно считается более гибким: объектный или классовый? Как это связано с принципами ООП? ⭐⭐
- Какие преимущества даёт классовый адаптер в C++ и какие ограничения он накладывает на архитектуру системы? ⭐⭐
- В каких случаях множественное наследование в классовом адаптере может стать источником проблем?
  Какие это проблемы (не только технические, но и архитектурные)? ⭐⭐⭐
- Рассмотрите слайд про «объём работы»: почему сложность адаптера пропорциональна размеру Target-интерфейса?
  Какие практики помогают уменьшить эту стоимость? ⭐⭐
- Что такое «замаскированные зависимости от конкретных классов» и почему они мешают внедрению адаптера?
  Приведите пример кода или ситуации. ⭐⭐⭐
- Почему адаптер легче внедрять в код, который зависит от интерфейсов? Как это связано с DIP (Dependency Inversion Principle)? ⭐⭐
- Можно ли считать адаптер нарушением SRP (Single Responsibility Principle)?
  Аргументируйте ответ и поясните, где проходит граница ответственности адаптера. ⭐⭐⭐
- Как адаптер помогает реализовать принцип Open/Closed? Какие изменения в системе должны происходить при смене внешнего API? ⭐⭐
- Чем адаптер отличается от фасада (Facade) по цели и эффекту на архитектуру? Приведите пример, где один паттерн подходит, а другой — нет. ⭐⭐⭐
- Чем адаптер отличается от прокси (Proxy)? В каких случаях прокси может выглядеть как адаптер и почему важно различать их намерение? ⭐⭐⭐
- Чем адаптер отличается от декоратора? Объясните разницу на уровне **контракта** и **намерения**.
  Приведите пример, где путаница приведёт к плохому дизайну. ⭐⭐⭐
- В каких ситуациях адаптер может «прятать» проблемы дизайна и откладывать рефакторинг, вместо того чтобы улучшать систему? ⭐⭐⭐
- Допустим, у вас есть несколько внешних библиотек с разными интерфейсами, но одинаковым смыслом.
  Как бы вы спроектировали систему адаптеров, чтобы клиентский код не зависел от конкретной библиотеки? ⭐⭐⭐
- Что делать, если адаптируемый интерфейс часто меняется (частые breaking changes)?
  Как организовать адаптеры и тесты, чтобы изменения локализовывались? ⭐⭐⭐
- Какие виды тестов наиболее важны для адаптера: модульные, контрактные, интеграционные?
  Что именно должен гарантировать тест адаптера? ⭐⭐
- Рассмотрите пример с ListView и `IListViewDataSource`. Почему это пример адаптера, даже если он выглядит как «просто интерфейс»?
  Где здесь Target и Adaptee? ⭐⭐⭐
- Почему вариант «передавать массив IListItemView» (готовые визуальные элементы) считается плохим решением?
  Объясните с точки зрения производительности, архитектуры и ответственности. ⭐⭐⭐
- Как адаптер в ListView помогает реализовать ленивое создание элементов (on-demand)?
  Какие преимущества это даёт? ⭐⭐
- Приведите пример адаптера для подключения клиента к нескольким TTS-сервисам.
  Какие интерфейсы вы бы сделали целевыми, и какие проблемы интеграции адаптер должен скрывать? ⭐⭐⭐
- Что такое **функциональный адаптер** (адаптация функции к другой сигнатуре/контракту)?
  Приведите пример преобразования входных данных и объясните, почему это тоже «Адаптер». ⭐⭐
- Приведите пример функционального адаптера, который превращает синхронную функцию в асинхронную (sync → async).
  Какие ограничения и гарантии должен соблюдать такой адаптер? ⭐⭐⭐
- Напишите адаптер, адаптирующий объекты `adaptee` к интерфейсам `target`. См. диаграмму классов:

  ```mermaid
  classDiagram
    namespace target {
      class IShape {
        <<interface>>
        GetStyle() IStyle&
      }

      class IStyle {
        <<interface>>
        GetColor() uint32
      }
    }

    namespace adaptee {
      class Shape {
        m_style: Style
        GetStyle() Style&
      }
      class Style {
        m_color: Color
        GetColor() Color
      }
      class Color {
        <<struct>>
        r: byte
        g: byte
        b: byte
        a: byte
      }
    }
    class Client {
    }

    IShape ..> IStyle
    Shape *-- Style
    Style *-- Color
    Client ..> IShape
    Client ..> IStyle
  ```

### Паттерн проектирования "Шаблонный метод"

- Объясните суть паттерна «Шаблонный метод» и сформулируйте, какой именно тип повторного использования он даёт. ⭐
- Почему «дублирование кода» часто является сигналом к архитектурным изменениям?
  Какие виды дублирования особенно опасны в OOP? ⭐⭐
- В «тривиальном решении» (когда `PrepareRecipe()` виртуальный/абстрактный и реализуется в каждом подклассе) какие проблемы появляются при изменении порядка шагов алгоритма?
  Объясните на уровне сопровождения и рисков регрессий. ⭐⭐
- Дайте определение «скелета алгоритма» в Template Method.
  Как отличить «скелет» от «деталей реализации» в реальном коде? ⭐⭐
- Почему в классическом Template Method базовый метод-шаблон (`PrepareRecipe`) часто делают **невиртуальным**? ⭐⭐
- Объясните разницу между **абстрактными шагами** (pure virtual) и **hooks** (виртуальные с реализацией по умолчанию).
  Приведите пример, когда hook лучше абстрактного метода. ⭐⭐
- Придумайте 2–3 разных типа hook’ов в шаблонном методе и поясните их влияние на расширяемость и читаемость. ⭐⭐
- В примере с `CustomerWantsCondiments()` какие риски вносит интерактивный ввод/IO в hook?
  Как бы вы тестировали такой код? ⭐⭐
- Как Template Method связан с Голливудским принципом («принцип инверсии управления»)?
  Опишите различие между *направлением зависимостей* и *направлением потока управления*. ⭐⭐
- Сравните DIP и Голливудский принцип: почему можно соблюдать один и нарушать другой? Приведите пример. ⭐⭐⭐
- Какие антипаттерны/запахи кода могут возникнуть при чрезмерном использовании Template Method? Как их распознать? ⭐⭐⭐
- Какие требования к контракту (pre/post conditions, инварианты) особенно важны в Template Method?
  Где их лучше фиксировать: в базовом методе или в шагах? Почему? ⭐⭐⭐
- Что такое идиома NVI (Non-Virtual Interface) и чем она отличается по фокусу от Template Method?
  В каких случаях NVI предпочтительнее? ⭐⭐
- Разберите пример `Document::Save()` (NVI): какие элементы “политики” централизованы в невиртуальном методе и почему это полезно для качества системы? ⭐⭐
- Почему сочетание `virtual` + default arguments в C++ опасно?
  Объясните механизм привязки значений по умолчанию и покажите, как NVI решает проблему. ⭐⭐⭐
- Какие шаги в Template Method стоит делать `private`, какие `protected`, а какие `public`?
  Обоснуйте с точки зрения инкапсуляции и защиты контракта. ⭐⭐
- Опишите типичные ошибки проектирования Template Method в C++: вызов виртуальных методов из конструктора/деструктора, “обходные” публичные виртуальные методы, нарушение инвариантов.
  Почему они опасны? ⭐⭐⭐
- Допустим, в шаблонном методе есть шаг, который должен быть выполнен *ровно один раз* (идемпотентность/инициализация).
  Где лучше хранить состояние и как избежать “частично инициализированного” объекта? ⭐⭐⭐
- Придумайте пример, где Template Method конфликтует с LSP (принцип подстановки Лисков).
  Что именно должен “сломать” подкласс, чтобы нарушить LSP? ⭐⭐⭐
- Как бы вы документировали точки расширения Template Method, чтобы избежать “магии фреймворка” и скрытых зависимостей порядка вызовов? ⭐⭐
- В каких ситуациях Template Method лучше заменить на Strategy? Сформулируйте критерии выбора. ⭐⭐
- Как Template Method соотносится с Factory Method? Приведите сценарий, когда Template Method вызывает фабричный метод на одном из шагов. ⭐⭐
- В примере “напитков” добавьте шаг “подогреть чашку” или “проверить наличие ингредиентов”. Куда вы его добавите и почему? ⭐⭐
- Опишите compile-time Template Method (CRTP): как переносится диспетчеризация из рантайма в компилятор?
  Какие требования предъявляются к Derived? ⭐⭐
- Какие ограничения CRTP-варианта критичны для архитектуры? Как бы вы смягчали эти ограничения? ⭐⭐⭐
- Почему “нестатические методы наследника нельзя вызывать из конструктора/деструктора родителя” особенно важно в CRTP-варианте?
  Приведите пример бага и способ избежать. ⭐⭐⭐
- Спроектируйте Template Method для Undo/Redo (команды): какие шаги должны быть инвариантными, а какие — вариативными? ⭐⭐⭐
- Приведите пример Template Method в UI/веб-фреймворке (pipeline обработки события/запроса).
  Какие hooks там обычно предоставляют, и какие риски создаёт неправильное использование hooks? ⭐⭐⭐
- Представьте, что вам нужно обеспечить единые политики для набора операций, где часть шагов вариативна.
  Как бы вы совместили Template Method и NVI так, чтобы подклассы не могли “обойти” политику? ⭐⭐⭐

### Паттерн проектирования "Итератор"

- Объясните, какую проблему решает паттерн «Итератор» и почему он относится к поведенческим паттернам. ⭐
- Почему перебор элементов через индексы (`GetBookAtIndex(i)`) может быть плохим решением? ⭐
- Какие недостатки появляются в коде, когда клиент напрямую зависит от типа контейнера (`deque`, `unordered_map` и т.д.)? ⭐⭐
- В чём заключается «раскрытие внутреннего представления коллекции» и почему это вредно? ⭐⭐
- Как новые требования ломают исходную архитектуру библиотеки? ⭐⭐
- Почему добавление индексов (`m_authorBooks`) может привести к дублированию кода обхода коллекции? ⭐⭐
- В чём разница между «данными» и «представлением данных» в контексте примера Library? ⭐⭐
- Какие принципы SOLID нарушаются в примере до введения итератора? Обоснуйте. ⭐⭐⭐
- Как паттерн «Итератор» помогает следовать принципу OCP (Open/Closed Principle)? ⭐⭐
- Почему «универсальная функция PrintBooks» — хороший критерий успешного внедрения итератора? ⭐⭐
- Опишите минимальный набор операций, который должен поддерживать итератор для корректного последовательного обхода. ⭐
- Почему в интерфейсе итератора разделяют методы `HasBook()` и `GetBook()` вместо одного метода “GetNext”? ⭐⭐
- Какие ошибки проектирования могут возникнуть, если `GetBook()` вызывают без проверки `HasBook()`? ⭐⭐
- Какие варианты поведения итератора возможны при выходе за границы коллекции? Как выбрать? ⭐⭐⭐
- Как вы объясните ответственность коллекции и ответственность итератора в паттерне? ⭐⭐
- Сравните внешний и внутренний итератор: где какой удобнее, и какие компромиссы по гибкости/контролю? ⭐⭐
- Приведите пример задачи, которую сложно реализовать внутренним итератором, но легко внешним. ⭐⭐
- Можно ли сказать, что range-based for в C++ использует итератор? Объясните, что за интерфейс там требуется. ⭐⭐
- Как паттерн «Итератор» связан с инкапсуляцией и сокрытием реализации? ⭐⭐
- В примере `BookByTitleIterator` хранит итератор по `unordered_map<string, const Book*>`.
  Какие риски появляются из-за хранения указателей? ⭐⭐⭐
- Как обеспечить корректность итераторов, если коллекция может изменяться во время обхода? Какие стратегии существуют? ⭐⭐⭐
- Почему в примере итераторы возвращаются через `std::unique_ptr<IBookIterator>`? Какие плюсы и минусы такого решения? ⭐⭐
- Как бы вы изменили дизайн, чтобы избежать heap-аллокаций при создании итератора (но сохранить полиморфизм)? ⭐⭐⭐
- Какие альтернативы виртуальному интерфейсу итератора существуют в C++ (шаблоны, концепты, type erasure)? Сравните. ⭐⭐⭐
- Зачем добавляют метод `Clone()` в интерфейс итератора и с каким паттерном он связан? ⭐⭐
- Почему копирование итератора нельзя корректно реализовать обычным копирующим конструктором базового интерфейса? ⭐⭐⭐
- В чём смысл класса-обёртки `BookIterator` и какие задачи он решает для клиента? ⭐⭐
- Какие инварианты и гарантии вы бы сформулировали для корректного итератора (валидность, неизменность позиции, исключения)? ⭐⭐⭐
- Спроектируйте расширение примера: итератор, который обходит книги только за заданный диапазон лет или только по префиксу названия.
  Где должна быть логика фильтрации — в коллекции, в итераторе или в отдельном объекте? Обоснуйте. ⭐⭐⭐

### Паттерн проектирования "Компоновщик"

- Дайте определение паттерна «Компоновщик» и объясните, какую проблему проектирования он решает на практике. ⭐
- В чём состоит ключевая идея «прозрачности» (transparency) в Composite и почему она важна для клиентского кода? ⭐⭐
- Объясните роли **Component / Leaf / Composite** и приведите пример соответствия этим ролям в задаче «слайд–фигуры–группы». ⭐
- Почему древовидная структура естественна для моделирования отношений «часть–целое»?
  Приведите 2–3 примера из реальных систем. ⭐
- Какие инварианты должны выполняться в корректной реализации Composite-дерева? ⭐⭐
- Опишите, как будет выглядеть интерфейс `IDrawable`/`IShape`, чтобы и листья, и группы можно было рисовать одинаково.
  Какие операции туда логично включать? ⭐⭐
- Что произойдёт архитектурно, если добавить группировку фигур “в лоб”, без Composite?
  Какие проблемы возникнут? ⭐⭐
- В примере со слайдами: почему удобно, что `Slide` тоже реализует `IDrawable`? Как это влияет на дизайн? ⭐⭐
- Как вы реализуете `GroupShape::Draw(canvas)` так, чтобы поведение соответствовало «группа ведёт себя как одна фигура»? ⭐
- Опишите корректную реализацию `GetFrame()` для группы фигур: какие случаи нужно учесть и почему пустая группа — отдельная проблема? ⭐⭐
- Как реализовать `SetFrame()` для группы так, чтобы изменения размеров/положения группы пропорционально изменяли детей?
  Какие ошибки и трудности возможны? ⭐⭐⭐
- Что такое Z-order и как порядок потомков в Composite влияет на отрисовку и пользовательские ожидания? ⭐⭐
- Какие варианты хранения детей вы бы выбрали в C++: `unique_ptr`, `shared_ptr`,
  ссылки/сырой указатель? Обоснуйте выбор для фигур/групп. ⭐⭐
- Объясните разницу между **композицией и агрегацией** в контексте групп фигур и приведите пример, когда нужна агрегация. ⭐⭐
- Зачем может понадобиться ссылка на родителя в узлах Composite? Какие операции она упрощает? ⭐⭐
- Какие риски возникают при хранении ссылок на родителей? Как обеспечить инвариант «если A.parent = B, то B содержит A»? ⭐⭐⭐
- Можно ли разрешить совместное использование компонентов (один дочерний объект у двух родителей)?
  Какие проблемы это создаёт для определения родителя, удаления и трансформаций? ⭐⭐⭐
- Объясните дилемму: где размещать операции `Add/Remove/GetChild` — в `Component` или только в `Composite`?
  Какие плюсы/минусы у каждого варианта? ⭐⭐⭐
- Опишите компромисс через `GetComposite()` (возвращает `nullptr` для листьев).
  В чём частичная потеря прозрачности и как клиент должен действовать? ⭐⭐
- Как лучше реализовать “неразумные” операции для листьев (например, `Add` у Leaf): пустая реализация, исключение, код ошибки?
  Обоснуйте. ⭐⭐
- Какие типичные логические ошибки возможны при построении структуры Composite и как их предотвращать? ⭐⭐
- Как бы вы реализовали проверку на циклы при `Add`? Какие компромиссы по производительности и удобству появляются? ⭐⭐⭐
- Зачем Composite может кешировать вычисления (например, bounding box группы)? Как организовать инвалидирование кэша при изменении детей? ⭐⭐⭐
- Опишите схему уведомлений “child changed → parent invalidates cache → уведомляет своего parent”. Какие варианты реализации? ⭐⭐⭐
- Почему часто Composite сочетают с Visitor?
  Приведите пример операции, которую лучше вынести в Visitor, а не добавлять в классы фигур/узлов. ⭐⭐
- Объясните связь Composite и Iterator: какие задачи решает внешний итератор по дереву,
  и почему это лучше, чем “ручная рекурсия” в клиентском коде? ⭐⭐
- Как реализовать обход дерева: DFS/BFS, “только листья”, “только видимые” — и где в дизайне лучше задавать стратегию обхода? ⭐⭐⭐
- Можно ли реализовать Composite без наследования через `std::variant`/`std::visit`?
  Какие преимущества и ограничения такого подхода по сравнению с виртуальными методами? ⭐⭐⭐
- Опишите функциональный вариант “Компоновщика” для команд: простые функции + макро-функция, работающая с контекстом (мутабельным или иммутабельным). Какие плюсы/минусы и где это применимо? ⭐⭐⭐

### Паттерн проектирования "Состояние"

- Что именно считается «внутренним состоянием» объекта в паттерне State и чем оно отличается от обычных полей класса? ⭐
- Почему реализация автомата через switch(m_state) быстро деградирует при добавлении новых состояний и действий?
  Приведи конкретные причины. ⭐
- Какие изменения в коде автомата придётся сделать, если добавить новое состояние (например, “WinnerState” — выдаёт 2 жвачки за одну монету) в варианте со switch? ⭐⭐
- В чём заключается нарушение принципа Open/Closed в реализации с enum State и switch?
  Почему это опасно на практике? ⭐⭐
- Опиши роль Контекста в паттерне State и перечисли, за что он должен отвечать, а за что — нет. ⭐⭐
- Как понять, какие фрагменты поведения нужно переносить из Контекста в состояния, а какие оставить в Контексте? ⭐⭐
- Почему в паттерне State клиент обычно не должен напрямую менять текущее состояние объекта?
  Какие проблемы это может вызвать? ⭐⭐
- Объясни разницу между «объект меняет поведение» и «объект меняет класс» в терминах паттерна State. Почему говорят, что “выглядит так, будто меняет класс”? ⭐⭐
- В примере автомата почему метод TurnCrank() вызывает и TurnCrank(), и Dispense() у состояния?
  Какие плюсы и минусы у такого протокола вызовов? ⭐⭐⭐
- Какие риски появляются, если позволить состояниям напрямую менять поля Контекста (например, m_count), минуя интерфейс IGumballMachine? ⭐⭐
- Зачем вводить интерфейс IGumballMachine для состояний, если у нас уже есть класс GumballMachine? ⭐⭐
- Почему в примере класс GumballMachine приватно наследуется от IGumballMachine? Какой архитектурный смысл в этом решении? ⭐⭐
- Какие альтернативы приватному наследованию подходят для языков, где оно отсутствует (Java/C#)?
  Как бы вы это спроектировали? ⭐⭐
- Какие именно зависимости возникают между классами состояний, если состояния будут создавать друг друга напрямую (new HasQuarterState(...)) или ссылаться друг на друга? ⭐⭐⭐
- Объясни два подхода: кто выбирает следующее состояние — Контекст или сами состояния.
  Когда предпочтителен каждый вариант? ⭐⭐⭐
- Какой вариант управления переходами лучше защищает от изменений: закрывать Контекст или закрывать состояния
  Обоснуйте через OCP. ⭐⭐⭐
- Как бы вы реализовали логирование/трассировку переходов между состояниями так, чтобы не нарушить SRP и не размазать std::cout по всем классам? ⭐⭐⭐
- Если в системе нужно “откатить” состояние назад (undo), как это влияет на архитектуру State?
  Какие паттерны можно комбинировать? ⭐⭐⭐
- В чём сходство диаграмм State и Strategy и почему при этом смысл у них принципиально разный? ⭐⭐
- Приведите пример системы, где ошибочно применили Strategy вместо State (или наоборот), и объясните, какие симптомы покажут неправильный выбор. ⭐⭐⭐
- Какие признаки в коде указывают, что пора переходить от if/switch к паттерну State? ⭐⭐
- В каких случаях паттерн State будет избыточным усложнением? Как бы вы аргументировали отказ от него? ⭐⭐
- Что произойдёт с тестируемостью системы после внедрения State? Какие тесты станет проще писать, а какие — сложнее? ⭐⭐⭐
- Как лучше организовать создание объектов состояний: (а) заранее и навсегда или (б) по требованию? Какие критерии выбора вы бы использовали? ⭐⭐
- Почему “совместное использование объектов состояний разными контекстами” возможно только при условии, что состояния stateless? ⭐⭐⭐
- Можно ли делать состояния stateful (хранящими данные)? Когда это оправдано, и какие новые риски появляются? ⭐⭐⭐
- State — интерфейс или абстрактный класс? В каких случаях ты выберешь каждый вариант и почему? ⭐⭐
- Спроектируй расширение автомата: добавь состояние “ServiceMode” (обслуживание),
  в котором клиент не может покупать, но техник может пополнять жвачки.
  Какие классы/методы появятся, какие переходы изменятся, и как сохранить чистую архитектуру? ⭐⭐⭐

### Паттерн проектирования "Заместитель"

- Объясните паттерн Proxy своими словами: какую проблему он решает? ⭐
- Какие признаки в архитектуре подсказывают, что нужен Proxy, а не просто «вынести код в отдельный класс»? ⭐⭐
- Опишите минимальную структуру Proxy (Subject / RealSubject / Proxy). Какие зависимости допустимы, а какие приведут к «протеканию абстракции»? ⭐⭐
- Почему важно, чтобы клиент «не знал и не обязан знать», что работает с Proxy? Какие последствия возникают, если клиент начинает делать проверки вида `if (obj is Proxy)`? ⭐⭐
- Чем Proxy принципиально отличается от Adapter? Приведите пример ситуации, где визуально структуры похожи, но намерение разное. ⭐⭐
- Чем Proxy принципиально отличается от Decorator? Сформулируйте критерий, по которому вы точно определите выбор на практике. ⭐⭐
- Кэширование можно реализовать и как Proxy, и как Decorator. Опишите два варианта постановки задачи, которые приведут к разным решениям, и как это отразится на публичном API. ⭐⭐⭐
- Объясните Virtual Proxy: что именно считается «дорогим» в создании объекта, и как Proxy помогает уменьшить стоимость старта системы? ⭐
- В примере с `ImageProxy`: почему Proxy хранит «примерный размер» (`m_size`) до загрузки реального изображения? Какие компромиссы точности/удобства тут заложены? ⭐⭐
- Как бы вы спроектировали Virtual Proxy, если реальный объект может **не только долго создаваться**,
  но и часто **падать при загрузке**? Какие состояния и переходы должны быть у Proxy? ⭐⭐
- В `ImageProxy::Impl::Draw()` используется `weak_from_this()` и `lock()`.
  Объясните, какую проблему это решает в асинхронном callback, и что может пойти не так без этого. ⭐⭐⭐
- Как реализовать «частичную функциональность» в Virtual Proxy? Как при этом не сломать LSP? ⭐⭐⭐
- Что будет считаться «утечкой деталей реализации» Virtual Proxy в клиентский код? Приведите 2–3 примера таких утечек. ⭐⭐
- Объясните Remote Proxy: почему он считается разновидностью Proxy, а не просто сетевым клиентом?
  Какие свойства делают удалённость прозрачной? ⭐⭐
- В примере с утками: какие обязанности у DuckProxy, а какие — у DuckStub? Почему важно разделять эти роли? ⭐⭐
- Опишите полный путь вызова `duck.Fly(...)` в Remote Proxy (по шагам, включая сериализацию/десериализацию, обработку ошибок). ⭐⭐
- В `DuckStub::HandleFly` параметры парсятся из строки. Какие проблемы появятся при усложнении протокола (версии, бинарные данные, совместимость)? Как бы вы это переработали? ⭐⭐⭐
- Как корректно моделировать и обрабатывать ошибки в Remote Proxy: таймауты, сетевые сбои, частичные отказы?
  Что должен «видеть» клиент: исключения, коды ошибок, ретраи? ⭐⭐⭐
- Что такое «семантическая прозрачность» Remote Proxy: в каких случаях невозможно сделать удалённый вызов полностью эквивалентным локальному? ⭐⭐⭐
- Как влияет Remote Proxy на контракт методов (идемпотентность, побочные эффекты, повторные вызовы при ретраях)? 
  Приведите пример, где наивный ретрай ломает бизнес-логику. ⭐⭐⭐
- Расскажите про Protection Proxy: что именно он должен проверять,
  и почему перенос этих проверок в RealSubject часто ухудшает дизайн? ⭐⭐
- В примере `DocumentProtectionProxy`: почему чтение разрешено всем, а редактирование/удаление — нет.
  Как бы вы расширили архитектуру, не раздувая Proxy условными операторами? ⭐⭐⭐
- Что лучше сделать при запрете операции в Protection Proxy: молча «return», логировать,
  бросать исключение, возвращать статус? От чего зависит выбор? ⭐⭐
- Опишите угрозы, которые Protection Proxy **не** решает.
  Какие архитектурные меры нужны, чтобы прокси действительно защищал? ⭐⭐⭐
- Что такое Smart Proxy, и чем он отличается от «просто логирования»?
  Какие признаки указывают, что вы строите именно Smart Proxy? ⭐⭐
- Объясните идею Copy-on-Write как Smart Proxy: какие инварианты должны соблюдаться, чтобы копия создавалась только при модификации? ⭐⭐
- В примере `CoW::Write()` (возвращающем ссылку) показана ошибка, когда сохраняют ссылку и меняют данные после копирования.
  Объясните, почему это ломает CoW, и как вспомогательный тип `WriteProxy` предотвращает проблему на уровне типов. ⭐⭐⭐

### Паттерн проектирования "Посетитель"

- Объясните идею паттерна Visitor своими словами: какую проблему он решает и почему она возникает именно в ООП-системах? ⭐
- В примере с фигурами: почему требование “легко менять формат вывода (Plain/XML/Binary)” приводит к необходимости пересмотреть дизайн? ⭐
- Какие недостатки “классического решения” с методами вроде `ToString()`, `ToXml()`, `ToBinaryArray()` проявляются при росте проекта? ⭐⭐
- Как связаны Visitor и принцип **Open/Closed (OCP)**? В каком смысле Visitor “открывает” систему для расширения? ⭐⭐
- Опишите роли в паттерне Visitor: **Visitor**, **ConcreteVisitor**, **Element**, **ConcreteElement**, **ObjectStructure**.
  Что делает каждая роль? ⭐⭐
- Что именно происходит во время вызова `shape.Accept(visitor)` на уровне диспетчеризации методов?
  Почему это называют “двойной диспетчеризацией”? ⭐⭐⭐
- Почему в Visitor метод `Accept()` обычно находится в базовом классе элементов (`Shape`),
  а методы `Visit(...)` — в посетителе? Какое это даёт разделение ответственности? ⭐⭐
- В примере со слайдами `StreamOutputVisitor` хранит `m_indent`. Какие преимущества это даёт? ⭐⭐
- Объясните, почему поддержка **pretty-print** в “классическом подходе” начинает выглядеть как “протаскивание контекста” через API.
  Какие проблемы это вызывает? ⭐⭐
- Как Visitor помогает объединять “родственные операции”?
  Приведите пример набора операций, которые логично держать в одном посетителе. ⭐
- В каких случаях Visitor становится антипаттерном или неоправданным усложнением?
  Назовите критерии, по которым вы бы отказались от Visitor. ⭐⭐
- Почему Visitor особенно хорошо подходит, когда
  “классы структуры меняются редко, а операции добавляются часто”? Раскройте этот компромисс. ⭐⭐
- Какие проблемы появляются, если структура классов (ConcreteElement) меняется часто,
  а посетителей много? Почему это болезненно? ⭐⭐
- Объясните недостаток Visitor “затрудняется добавление новых ConcreteElement”.
  Что именно приходится менять и почему это нарушает масштабируемость? ⭐⭐
- Как Visitor может привести к нарушению инкапсуляции?
  Какие “публичные геттеры” приходится добавлять и почему это может быть плохо? ⭐⭐⭐
- В примере `ShapeGroup` содержит коллекцию `Shapes`. Как Visitor корректно обходит дерево объектов и почему именно `ShapeGroup::Visit()` обычно рекурсивен? ⭐⭐
- В чём разница между Visitor для “плоской коллекции” и Visitor для “иерархии/дерева” объектов?
  Какие дополнительные вопросы появляются во втором случае? ⭐⭐
- Как бы вы реализовали несколько форматов сериализации (XML, JSON, Binary) через Visitor так, чтобы не дублировать общий код (например, обход дерева)? ⭐⭐⭐
- Объясните, что такое **циклическая зависимость** между Visitor и ConcreteElement в классическом Visitor.
  В чём её практический вред? ⭐⭐⭐
- Как работает **Acyclic Visitor** (ациклический посетитель) и какую проблему он решает по сравнению с классическим Visitor? ⭐⭐⭐
- Почему в Acyclic Visitor вводят пустой базовый интерфейс `VisitorBase`? Какую архитектурную роль он играет? ⭐⭐
- В Acyclic Visitor элементы используют `dynamic_cast` для определения, умеет ли посетитель их обрабатывать. Какие плюсы и минусы такого решения? ⭐⭐⭐
- Что произойдёт, если посетитель не поддерживает конкретный тип элемента в Acyclic Visitor? Как это влияет на корректность обхода и ожидания клиента? ⭐⭐
- В чём отличие Visitor “на виртуальных методах” от Visitor “на шаблонах” (template-based) в C++? Какие компромиссы по типобезопасности и гибкости? ⭐⭐⭐
- Как можно реализовать Visitor так, чтобы операции были **const-correct** (например, `Visit(const Rectangle&)`)? Почему это важно? ⭐⭐
- Объясните идею избавления от boilerplate-кода `Accept()` с помощью `Visitable<T, Base>` / `ConstVisitable<T, Base>`. Почему это работает? ⭐⭐⭐
- Почему подход с `CRTP` в контексте Visitor считается идиомой C++? Какие риски и ограничения он несёт (например, сложность чтения, ошибки наследования)? ⭐⭐⭐
- Представьте, что в систему добавляют новый тип фигуры `Polygon`. Опишите два сценария:
    **а)** классический Visitor,
    **б)** Acyclic Visitor,
    и сравните объём изменений, риски и влияние на существующий код. ⭐⭐⭐

### Паттерн проектирования "Прототип"

- В чём состоит основная идея паттерна Prototype и какую проблему создания объектов он решает? ⭐
- Почему подход «создать пустой объект и скопировать поля по очереди» часто не работает в ООП? Приведите минимум 2 причины. ⭐
- Как Prototype помогает клиенту создавать объекты, не зная их конкретных типов? ⭐
- В каких ситуациях Prototype предпочтительнее, чем прямой вызов конструктора? Приведите примеры. ⭐⭐
- В каких ситуациях Prototype предпочтительнее, чем фабричный метод/абстрактная фабрика, и почему? ⭐⭐
- Что означает «классы определяются во время выполнения» в контексте Prototype? Как это влияет на архитектуру? ⭐⭐
- Чем отличается «поверхностное» (shallow) клонирование от «глубокого» (deep)? Когда нужно каждое из них? ⭐⭐
- Какие типовые сложности возникают при глубоком клонировании графа объектов с циклическими ссылками? Как их решать? ⭐⭐⭐
- Какие инварианты класса могут быть нарушены при некорректной реализации Clone()? Приведите примеры инвариантов. ⭐⭐
- Почему важно, чтобы у базового интерфейса прототипа был виртуальный деструктор? ⭐
- Почему сигнатура `unique_ptr<Base> Clone() const` чаще удачнее, чем возврат сырого указателя? Какие риски она снимает? ⭐⭐
- Какие требования накладывает реализация `Clone()` через копирующий конструктор на тип `Impl`? ⭐
- В чём состоит дублирование кода в «наивной» реализации Clone() в каждом подклассе и как CRTP помогает его убрать? ⭐⭐
- Объясните идею CRTP в `PrototypeImpl<Impl, Interface>`. Почему внутри Clone делается `static_cast<const Impl*>(this)`? ⭐⭐
- Какие риски появляются из-за `static_cast` в CRTP-реализации, и как их минимизировать? ⭐⭐⭐
- Как влияет отсутствие конструктора по умолчанию у базового класса на проектирование `PrototypeImpl`? Зачем нужен `using Base::Base`? ⭐⭐
- Какие архитектурные плюсы даёт использование реестра прототипов (Prototype Registry) по сравнению с фабрикой? ⭐⭐
- Разберите пример `ShapeGroup`: какие требования к клонированию элементов группы и почему там нужен кастомный copy-конструктор? ⭐⭐
- Почему наследование `Worker` от конкретного `Person` (в примере со слайда) является “красным флагом”? Назовите минимум 3 причины. ⭐⭐
- Как в этом примере может быть нарушен LSP? Сформулируйте возможные пред/постусловия у `Person::SpendDay()` и как их нарушит `Worker`. ⭐⭐⭐
- Что такое Fragile Base Class Problem и как он проявляется в иерархии `Person` → `Worker` при эволюции кода? ⭐⭐
- Что означает “Refused Bequest” (отвергнутое наследство) и как оно может привести к лишним полям и ухудшению производительности? ⭐⭐
- Какие подходы исправления проблем наследования от конкретного класса вы бы выбрали в разных сценариях: NVI/Template Method, композиция, стратегия, mixin? Обоснуйте. ⭐⭐⭐
- Зачем в варианте с `PersonImpl<Base>` метод `GetName()` делают `final`? Какие компромиссы и альтернативы есть? ⭐⭐
- Какие риски у решения через mixin-ы и шаблонное наследование? Как их контролировать? ⭐⭐⭐
- Какие проверки стоит добавить в `PrototypeImpl` с помощью C++20 Concepts/`static_assert`, и какие ошибки они позволяют ловить раньше? ⭐⭐
- Почему `std::any` не поддерживает «восходящее» приведение к базовому типу (`any_cast<IShape&>` при хранении `Circle`), и как это влияет на дизайн type-erasure? ⭐⭐
- Сравните два подхода “классический полиморфизм через `unique_ptr<IShape>`” и “type erasure через `std::any`”
  с точки зрения: производительности (конструирование vs вызовы), владения,
  локальности данных, расширяемости и сложности реализации. ⭐⭐⭐

### Паттерн проектирования "Строитель"

- Объясните назначение паттерна Builder своими словами и приведите пример ситуации, где он лучше конструктора или фабрики. ⭐
- Почему Builder формулируют как «отделяет конструирование сложного объекта от его представления»?
  Что именно отделяется и какие проблемы это решает? ⭐⭐
- Опишите роли **Director**, **Builder**, **ConcreteBuilder**, **Product**, **Client** и их ответственность в терминах SRP (Single Responsibility Principle). ⭐⭐
- В чём разница между Builder и Abstract Factory?
  Приведите пример, где эти паттерны выглядят похоже, но дают разные архитектурные свойства. ⭐⭐
- Почему в классическом Builder распорядитель (Director) работает через **абстрактный интерфейс Builder**,
  и что это даёт с точки зрения OCP (Open/Closed Principle)? ⭐⭐
- Какие признаки в коде указывают, что пора внедрять Builder? ⭐
- Можно ли применять Builder для простых объектов из 2–3 полей? Обоснуйте, когда это будет вредно. ⭐⭐
- В задаче «экспорт документа в разные форматы» какие сущности логично сделать продуктами Builder, а какие — частями процесса сборки? ⭐⭐
- Спроектируйте интерфейс Builder для экспорта документа так, чтобы один и тот же процесс сборки мог создавать продукты:
  JSON+images, XML+images, бинарный формат. Какие методы вы бы включили и почему? ⭐⭐⭐
- Должен ли у продукта быть общий интерфейс или базовый класс? ⭐⭐
- Что означает «продукт создаётся шаг за шагом»? Приведите пример набора шагов для сборки документа в PDF или HTML. ⭐
- Как бы вы реализовали Builder для экспорта в **Plain Text**, чтобы он корректно обрабатывал форматирование, изображения и метаданные документа? ⭐⭐
- Какие инварианты и проверки корректности удобнее делать в Builder, а какие — в Director? Обоснуйте архитектурно. ⭐⭐⭐
- В каких случаях Builder должен предоставлять доступ к «частично собранному продукту»? Приведите пример из лекции и объясните, зачем это нужно. ⭐⭐⭐
- Почему в классической реализации Builder допускается, что методы базового Builder могут быть «пустыми» (no-op)
  вместо абстрактных? Какие плюсы и минусы у этого решения? ⭐⭐⭐
- Опишите, как Builder помогает «изменять внутреннее представление продукта», не меняя код Director. Приведите пример. ⭐⭐
- Что произойдёт, если Director начнёт знать конкретные классы продукта (например, PDFDocument, HtmlDocument)?
  Какие принципы проектирования будут нарушены? ⭐⭐
- Builder обычно создаёт один продукт за один цикл сборки.
  Как обеспечить возможность повторного использования одного Builder для нескольких продуктов, и какие риски это несёт? ⭐⭐
- В чём отличие «классического Builder (Director + Builder)» от «Fluent Builder (цепочки вызовов)»? Когда какой вариант предпочтительнее? ⭐⭐
- Какие проблемы возникают, если Builder хранит слишком много состояния и становится «вторым продуктом»? Как этого избежать? ⭐⭐⭐
- Рассмотрите сценарий: экспорт документа должен быть расширяемым (добавим EPUB через месяц).
  Как Builder помогает сделать это изменение минимальным? ⭐⭐
- Назовите недостаток Builder из лекции и предложите 2 способа уменьшить количество классов без потери расширяемости. ⭐⭐⭐
- Объясните, как Builder может сочетаться с паттерном **Команда** (Command) в архитектуре приложения. ⭐⭐⭐
- В задаче экспорта без потери информации: как Builder должен работать с ресурсами (изображения, вложения) и ссылками на них, чтобы поддержать JSON/XML + отдельные файлы? ⭐⭐⭐
- Как бы вы обеспечили единый «процесс конструирования» для экспорта в HTML и PDF, если они требуют разных структур (DOM vs страницы/рендеринг)? ⭐⭐⭐
- Приведите пример ситуации, когда Director не нужен, и клиент может напрямую управлять Builder. Почему это допустимо? ⭐⭐
- Builder часто применяют для immutable объектов. Объясните, почему Builder хорошо сочетается с неизменяемостью и какие ошибки при этом допускают. ⭐⭐
- Как отличить Builder от Factory Method в реальном коде, если оба создают объекты?
  На какие признаки в API и ответственности классов вы бы смотрели? ⭐⭐
- Предложите дизайн, где один и тот же документ можно сохранить в разных форматах,
  не меняя код документа и минимально меняя код экспортёра. Какие паттерны вы бы использовали и почему? ⭐⭐⭐

### Паттерн проектирования "Мост"

- Объясните, в чём состоит ключевая идея паттерна «Мост» и какую проблему проектирования он решает. ⭐
- Что в паттерне «Мост» является **абстракцией**, а что — **реализацией**? Приведите пример на основе окон GUI. ⭐
- Почему добавление новой платформы (например, MacOS X) приводит к “взрыву количества классов” в наивной реализации UI-библиотеки? ⭐⭐
- Какие признаки в коде и структуре классов подсказывают, что пора применять «Мост»? ⭐⭐
- Что означает фраза: «Абстракция и реализация должны расширяться независимо»? Объясните на примере. ⭐⭐
- Какие риски возникают для сопровождения и тестирования, если клиентский код зависит от классов конкретной платформы? ⭐⭐
- Почему фабрика сама по себе не решает проблему сильной связности абстракции и реализации? ⭐⭐
- Опишите структуру паттерна Bridge (Abstraction, RefinedAbstraction, Implementor, ConcreteImplementor) и ответственность каждого элемента. ⭐⭐
- Какой тип связи между `Window` и `WindowImp` является ключевым в паттерне «Мост» и почему? ⭐⭐
- Какие два “непересекающихся измерения” чаще всего выделяют при применении Bridge? Приведите 2–3 пары. ⭐
- Почему в Bridge обычно используется **композиция**, а не наследование? Какие преимущества это даёт с точки зрения ООП? ⭐⭐
- Объясните, как Bridge помогает следовать принципу **Open/Closed (OCP)**. ⭐⭐
- Представьте, что вам нужно добавить новый тип окна (например, `PopupWindow`) и новую платформу (`Wayland`).
  Какие классы изменятся при использовании Bridge и какие — при наследовании без Bridge? ⭐⭐⭐
- Как в Bridge организовать возможность выбора реализации **во время выполнения**?
  Приведите сценарий, где это реально нужно. ⭐⭐
- Какие недостатки паттерна «Мост» проявляются в небольших проектах и почему его иногда считают “overengineering”? ⭐⭐
- В каких случаях Implementor стоит делать интерфейсом, а в каких — обычным классом? Обоснуйте архитектурно. ⭐⭐
- Кто должен создавать `ConcreteImplementor` в Bridge: сама `Abstraction`, клиент, фабрика или DI-контейнер? Сравните варианты и их последствия. ⭐⭐⭐
- В лекции упоминается совместное использование реализаций между несколькими объектами абстракции.
  Зачем это может быть нужно и какие проблемы при этом возникают? ⭐⭐⭐
- Как вы бы реализовали Bridge так, чтобы одна реализация могла безопасно использоваться несколькими абстракциями? ⭐⭐⭐
- Сравните паттерны **Bridge** и **Adapter**: чем отличается их цель, когда они применяются и что происходит с зависимостями в системе? ⭐⭐
- Объясните, как паттерн **Builder** может быть “построен в виде моста”: кто играет роль абстракции и кто — реализации? ⭐⭐⭐

### Архитектура GUI-приложений. Document-View

- Объясните, какую проблему Smart UI решает “быстро”, и почему эта же особенность превращается в архитектурный долг по мере роста приложения. ⭐⭐
- Опишите паттерн **Document–View** своими словами: какие обязанности у **Document**, а какие у **View** (минимум 3 пункта на каждый). ⭐⭐
- Почему в Document–View считается принципиальным, что **состояние отделено от визуального представления**? Какие изменения в разработке это упрощает? ⭐⭐
- Как событийно-ориентированная модель GUI (цикл сообщений, IoC) влияет на взаимодействие Document и View? Где должен “жить” код реакции на события пользователя? ⭐⭐
- В каких случаях Document–View предпочтительнее MVC/MVP/MVVM и почему? Сформулируйте критерии выбора. ⭐⭐⭐
- Какие требования к интерфейсу Document (модели): какие методы он обязан предоставлять, чтобы View могла корректно обновляться и при этом не нарушать инкапсуляцию? ⭐⭐
- Зачем Document предоставляет механизм уведомления об изменениях? Какие сценарии становятся невозможными или слишком хрупкими без уведомлений? ⭐⭐
- Какие риски возникают из-за хранения “сырых” указателей на слушателей в Document? Как можно улучшить дизайн с точки зрения безопасного владения/времени жизни объектов? ⭐⭐⭐
- Объясните, зачем View подписывается на Document в `OnCreate`, а отписывается в `OnDestroy`. Почему подписка/отписка не должна быть “где-то в конструкторе/деструкторе” без учёта жизненного цикла окна? ⭐⭐⭐
- Что произойдёт, если забыть вызвать `RemoveListener(*this)` при уничтожении View? Опишите возможные симптомы и типы багов. ⭐⭐⭐
- Почему `View : private IDocumentListener` (приватное наследование) может быть осознанным решением? Чем это отличается от public-наследования в плане API и инкапсуляции? ⭐⭐⭐
- Почему у `IDocumentListener` деструктор **protected и невиртуальный**? Какой контракт использования интерфейса этим выражается, и какие ошибки это предотвращает? ⭐⭐⭐
- Предположим, что у одного Document есть **несколько View** (например, главное окно и отдельная панель/индикатор). Как обеспечить согласованность обновлений и избежать “лишних” перерисовок? ⭐⭐⭐
- Чем Document–View отличается от Smart UI по тестируемости? Какие unit-тесты появляются для Document, и какие всё равно остаются сложными? ⭐⭐
- Какие принципы SOLID усиливаются при переходе от Smart UI к Document–View, а какие могут быть нарушены при неаккуратной реализации? ⭐⭐⭐

### Архитектура GUI-приложений. Model-View-Controller

- Опишите MVC своими словами: какие обязанности у **Model**, **View**, **Controller**,
  и какие признаки говорят, что границы ответственности нарушены? ⭐⭐
- Объясните, как **событийно-ориентированная модель GUI** и **инверсия управления фреймворком** влияют на то, где должен находиться код обработки действий пользователя в MVC. ⭐⭐
- Сравните Smart UI и MVC: какие именно проблемы Smart UI решает “быстро”,
  и какие архитектурные ограничения MVC устраняет? ⭐⭐
- Почему в MVC обычно запрещают View напрямую модифицировать Model?
  Опишите минимум два класса ошибок, которые это предотвращает. ⭐⭐⭐
- Из чего состоит “контур обновления UI” в MVC?
  Разберите два сценария обновления View: **по уведомлению модели** и **по уведомлению от ОС/фреймворка**. ⭐⭐
- Объясните тезис: “Представление в MVC имеет сильную зависимость от модели”.
  Какие плюсы даёт такая зависимость, и какие минусы приносит (особенно для тестирования)? ⭐⭐⭐
- Чем отличается **View** от **widgets**? Почему виджеты не должны знать о модели,
  а View отвечает за синхронизацию состояния виджетов? ⭐⭐
- В чём смысл фразы “представление — это не только графика”
  Как бы вы встроили звук/вибрацию в MVC, чтобы не нарушить SRP и границы слоя представления? ⭐⭐⭐
- В каких случаях это правило "контроллер обычно связан с представлением **1 к 1**" полезно,
  а в каких — становится ограничением? Приведите пример и альтернативу. ⭐⭐⭐
- Контроллер “обычно направляет запросы на изменение модели”, но может модифицировать и View.
  В каких ситуациях прямое обновление View контроллером оправдано, а когда это архитектурный запах? ⭐⭐⭐
- Опишите, какие “сервисы” должна предоставлять модель в MVC.
  Где проходит граница между доменной логикой и “логикой приложения”? ⭐⭐
- Что означает “модель полностью независима от UI”? Какие виды зависимостей допустимы, а какие недопустимы? ⭐⭐⭐
- Объясните, что такое **целостность данных** в модели и почему она не всегда равна “валидности”.
  Приведите пример UI-сценария, где модель проходит через невалидные состояния к валидному. ⭐⭐⭐
- Сравните **пассивную**, **активную** и **ленивую** модель как стратегии уведомления.
  Какие компромиссы по синхронизации, сложности и контролю перерисовок у каждой? ⭐⭐⭐
- Почему пассивная модель осложняет синхронизацию нескольких View, если модель меняют разные контроллеры?
  Опишите конкретный сценарий рассинхронизации и способ исправления. ⭐⭐⭐
- Если приложение состоит из нескольких слабосвязанных MVC-триад, какие практики помогают не превратить систему в “комок связей”? ⭐⭐⭐

### Архитектура GUI-приложений. Model-View-Presenter

- Объясните, зачем в архитектурах уровня MVP/MVVM стремятся сделать так, чтобы **View не знало модель напрямую**.
  Какие проблемы это решает? ⭐⭐
- Сравните Smart UI и Passive View: что именно “переезжает” из View наружу, и почему это повышает тестируемость? ⭐⭐
- Опишите паттерн **Passive View**: какие обязанности остаются у View, а какие переходят к Controller/Presenter?
- Почему подчёркивается “отсутствие связей между моделью и представлением”? ⭐⭐⭐
- Чем **Supervising Controller** отличается от “полностью пассивного” подхода, и почему формула “MVP = SupervisingController + PassiveView” может быть полезной? ⭐⭐⭐
- В MVP Presenter является посредником между Model и View.
  Опишите полный цикл: событие пользователя → Presenter → Model → обновление View. ⭐⭐
- Почему в MVP Presenter не должен содержать UI-кода и обращаться к View только через интерфейс?
  Каким ООП-принципам это соответствует? ⭐⭐⭐
- Что такое **View State** в MVP? Приведите примеры “представленческого состояния”,
  которое не относится к предметной области. ⭐⭐
- Объясните, что означает “Presenter инкапсулирует преобразование данных модели в формат, удобный для View”.
  Чем опасно делать эти преобразования прямо в View? ⭐⭐
- Опишите подход **Presenter First**. Почему в нём Presenter может “вообще не иметь публичных методов”,
  и как тогда выглядят границы и точки входа? ⭐⭐⭐
- Сравните MVP и MVC: кто является “инициатором” обновления View, и почему в MVP обычно легче писать изолированные тесты поведения UI? ⭐⭐⭐
- В каких ситуациях MVP предпочтительнее MVVM (и наоборот)?
  Приведите критерии выбора, связанные с фреймворком, сложностью UI и командой. ⭐⭐⭐
- Опишите MVVM: роли **Model / View / ViewModel**, и какие зависимости допустимы между ними (в идеальном варианте). ⭐⭐
- Почему ViewModel “не должна зависеть от конкретного класса View”?
  Какие типичные ошибки приводят к скрытой зависимости на UI? ⭐⭐⭐
- Как в MVVM реализуется передача действий пользователя без вызовов методов ViewModel из кода View? Какие архитектурные преимущества это даёт? ⭐⭐⭐
- Что такое **двусторонний data binding**, и какие риски он несёт? Как эти риски контролировать? ⭐⭐⭐
- Зачем ViewModel уведомляет View об изменениях (например, через `INotifyPropertyChanged`)?
  Какие проблемы возникнут, если уведомления будут “слишком частыми” или “слишком редкими”? ⭐⭐
- Сравните стратегии уведомления модели (пассивная/активная/ленивая) с точки зрения MVP и MVVM:
  где чаще какая стратегия уместна и почему? ⭐⭐⭐
- Объясните тезис “модель обеспечивает целостность данных, но не всегда валидность”.
  Как это отражается на дизайне Presenter/ViewModel при вводе данных пользователем? ⭐⭐⭐
- Опишите, как бы вы тестировали логику Presenter или ViewModel без реального UI: какие **Test Double** (stub/mock/spy/fake/dummy) вы бы использовали и для чего именно? ⭐⭐⭐

## Принципы проектирования ПО

### Отношения между классами

- Визуализация структуры программы на диаграмме классов.
  - Как обозначаются классы на диаграмме классов?
  - Как обозначаются абстрактные классы?
  - Как обозначить видимость методов и данных на диаграмме классов?
  - Как обозначаются статические методы и данные на диаграмме классов?
  - Как обозначаются абстрактные методы?
- Композиция.
  - Что такое композиция?
  - Когда возникает отношение композиции между классами?
  - Обозначение композиции на диаграмме классов.
  - Приведите пример использования композиции в реальной программе.
  - Сокрытие данных при композиции.
- Агрегация
  - Что такое агрегация?
  - Когда возникает отношение агрегации?
  - Обозначение агрегации на диаграмме классов.
  - Сокрытие данных при агрегировании.
  - Приведите пример агрегации в реальной программе.
  - Отличие агрегации и композиции.
- Зависимость
  - Что такое зависимость?
  - Когда возникает отношение зависимости между классами?
  - Обозначение зависимости на диаграмме классов.
  - Что такое транзитивность зависимостей?
  - Приведите пример зависимости в реальной программе.
- Наследование
  - Что такое наследование? Какое отношение между классами существует при наследовании?
  - Как наследование обозначается на диаграмме классов?
- Интерфейсы
  - Как отображаются интерфейсы на диаграмме классов.
  - Каким отношениями могут и не могут быть связаны интерфейсы с другими программными сущностями?
  - Как на диаграмме классов обозначается класс, реализующий интерфейс?
  - Может ли один интерфейс быть унаследован от другого?

### Принцип единственной ответственности (SRP)

- Объясните принцип SRP своими словами. Что именно означает «одна причина для изменений»
  и чем она отличается от «класс делает одну задачу»? ⭐⭐
- Что такое «актор» (источник требований) в контексте SRP? Приведите 2–3 примера акторов в реальном проекте. ⭐⭐
- Почему класс, который «умеет всё понемногу» (чтение файла, валидация, преобразование, логирование), становится хрупким?
  Опишите типичный сценарий поломки. ⭐⭐
- Примените «тест одного предложения» к классу `Bitmap`, который хранит пиксели, рисует линии и сохраняет файл. Как вы сформулируете ответственность до и после рефакторинга? ⭐
- В примере с `Bitmap`: какие две ответственности были вынесены из класса,
  и почему именно они являются отдельными причинами для изменений? ⭐⭐
- Чем отличается «вынести методы в отдельный класс» от «сделать отдельный модуль/компонент»?
  В каких случаях SRP нужно применять на уровне модулей, а не классов? ⭐⭐⭐
- После применения SRP код стал более многословным. Почему это *не всегда* плохо?
  В каких случаях многословность превращается в реальную проблему? ⭐⭐
- Объясните проблему discoverability после рефакторинга `Bitmap`.
  Какие практические способы вы бы использовали, чтобы её снизить, не нарушая SRP? ⭐⭐⭐
- Какие признаки в коде подсказывают, что SRP нарушен, даже если класс «не выглядит большим»?
  Приведите несколько сигналов. ⭐⭐
- Представьте класс `UserService`, который: валидирует пользователя, сохраняет в БД и отправляет email.
  Как вы выделите ответственности и какие классы/интерфейсы появятся? ⭐⭐
- Как SRP влияет на тестирование? Приведите пример: какие тесты становятся проще после разделения ответственностей? ⭐⭐
- В каких случаях нарушение SRP может быть оправдано?
  Приведите пример из практики, где «смешение ответственностей» — разумный компромисс. ⭐⭐⭐
- Что опаснее: нарушить SRP в доменной логике или в инфраструктурном коде (например, сериализация/логирование)? Обоснуйте. ⭐⭐⭐
- Почему после применения SRP часто «растёт количество классов»?
  Как отличить нормальную декомпозицию от архитектурного «размножения сущностей»? ⭐⭐⭐
- Опишите, как SRP помогает расширяемости на примере: добавление нового примитива рисования (например, окружности) и добавление нового формата сохранения. ⭐⭐
- В примере `PngImageEncoder`: почему сохранение вынесено в отдельный класс, а не добавлено в `Bitmap` через метод `SavePng()`?
  Какие риски были бы у второго варианта? ⭐⭐
- Предложите альтернативное решение, которое соблюдает SRP, но делает API удобнее: как можно упростить сохранение в один вызов? ⭐⭐⭐
- Чем SRP отличается от «God Object» как антипаттерна?
  Может ли класс не быть God Object, но при этом нарушать SRP? Приведите пример. ⭐⭐⭐
- Как SRP связан с другими принципами SOLID: OCP и DIP?
  Объясните, как SRP подготавливает почву для расширяемости без изменений. ⭐⭐⭐
- Представьте, что вы делаете код-ревью.
  Какие вопросы вы зададите автору класса, чтобы проверить соблюдение SRP (без переписывания кода прямо сейчас)? ⭐⭐

### Принцип открытости-закрытости (OCP)

- Сформулируйте принцип OCP своими словами.
  Что означает «открыт для расширения» и «закрыт для изменения» в контексте реального проекта? ⭐⭐
- Почему «закрыт для изменения» не означает «код никогда нельзя менять»?
  В каких случаях изменение существующего кода является нормальным и ожидаемым? ⭐⭐⭐
- Приведите пример требования, которое в плохой архитектуре приводит к большим правкам,
  а в хорошей — к добавлению нового кода без изменения старого. Объясните разницу. ⭐⭐
- Какие признаки в коде говорят о нарушении OCP? Перечислите 3–5 сигналов. ⭐⭐
- В примере с `Logger`, почему зависимость от `std::ofstream` является проблемой с точки зрения OCP?
  Какой «вариант изменения требований» ломает этот дизайн? ⭐⭐
- В примере с `ILogSink`: какая часть поведения была выделена как изменяемая?
  Почему именно её нужно было «вынести наружу»? ⭐⭐
- Почему решение через `ILogSink` делает систему расширяемой?
  Опишите, как добавить `SyslogSink` или `NetworkSink`, не меняя `Logger`. ⭐
- В чём архитектурная цена решения через интерфейсы (`ILogSink`, `IReportFormatter`)?
  Какие риски появляются при росте числа абстракций? ⭐⭐
- Объясните разницу между расширением поведения через **наследование** и через **композицию** в контексте OCP.
  Когда что предпочтительнее? ⭐⭐⭐
- В каких случаях параметризация поведением через лямбды или `std::function`
  может быть лучшим способом соблюсти OCP, чем создание иерархии классов? ⭐⭐⭐
- Как в C++ можно реализовать OCP на этапе компиляции?
  Опишите идею «policy-based design» или шаблонного параметра поведения. ⭐⭐⭐
- Приведите пример, где OCP реализуется через шаблонный параметр. Какие плюсы и минусы такого подхода? ⭐⭐⭐
- В примере с рендерингом отчёта: почему попытка добавить поддержку разных форматов через `if/else` внутри `ReportRenderer` является нарушением OCP? ⭐⭐
- Какие изменения требований к форматированию чисел (группировка разрядов, валюта, разделители, скобки для отрицательных) должны приводить к добавлению нового класса, а какие — к изменению существующего? Обоснуйте. ⭐⭐⭐
- Объясните, как паттерн **Strategy** помогает соблюдать OCP на примере `IReportFormatter` или `ILogSink`. ⭐⭐
- Как паттерн **Decorator** может быть применён для расширения логгера (например, добавление timestamp, фильтрация по уровню, буферизация) без изменения исходного класса? ⭐⭐⭐
- Как паттерн **Template Method** может помочь соблюсти OCP? Приведите пример алгоритма, где меняются только отдельные шаги. ⭐⭐⭐
- Как паттерны **Factory Method** и **Abstract Factory** связаны с OCP? Почему создание объектов часто становится «точкой расширения»? ⭐⭐⭐
- Что такое «преждевременная абстракция» в контексте OCP? Приведите пример, когда попытка «сделать расширяемо заранее» приводит к ухудшению дизайна. ⭐⭐⭐
- Представьте, что вы проводите код-ревью. Какие вопросы вы зададите автору, чтобы понять: реализован ли OCP осознанно, или код стал “расширяемым ради расширяемости”? ⭐⭐

### Принцип подстановки Лисков (LSP)

- Сформулируйте LSP своими словами и объясните, чем «взаимозаменяемость» отличается от простого «наследования по смыслу». ⭐⭐
- Почему нарушения LSP особенно опасны в статически типизированных языках? Опишите типичный сценарий «всё компилируется, но работает неправильно». ⭐⭐
- Что такое контракт базового типа? Назовите его элементы (предусловия, постусловия, инварианты) и объясните их роль в LSP. ⭐⭐
- Приведите пример усиления предусловия в подклассе и объясните, почему это нарушает LSP. ⭐⭐
- Приведите пример ослабления постусловия в подклассе и объясните, как это ломает ожидания клиента базового типа. ⭐⭐
- Что означает «подкласс может ослаблять предусловия»? Приведите практический пример, где это полезно и корректно. ⭐⭐⭐
- Что означает «подкласс может усиливать постусловия»? Приведите практический пример, где подкласс даёт более сильные гарантии, чем базовый. ⭐⭐⭐
- Что такое инвариант базового класса? Приведите 2 примера инвариантов и покажите, как их нарушение в подклассе приводит к ошибкам. ⭐⭐⭐
- Объясните, почему пример Rectangle/Square нарушает LSP именно на уровне поведения, а не на уровне математики. ⭐⭐
- Составьте пример клиентского кода (функции), который корректно работает с `Rectangle`, но ломается при подстановке `Square`. Объясните, какое ожидание нарушено. ⭐⭐
- Почему «кидать исключение в неподдерживаемом методе» (например, `throw` вместо реализации) часто является нарушением LSP? Когда это может быть допустимо? ⭐⭐⭐
- Сравните способы решения проблемы Rectangle/Square: «разные классы через общий интерфейс» vs «immutable объекты». В чём различие по контрактам и по последствиям для API? ⭐⭐⭐
- В чём идея решения «Square как фабрика Rectangle», и какие плюсы/минусы у такого подхода с точки зрения модели предметной области? ⭐⭐⭐
- Объясните решение «общий абстрактный тип без сеттеров размеров». Почему удаление операций изменения из базового интерфейса может восстановить LSP? ⭐⭐⭐
- Приведите пример, где отказ от наследования в пользу композиции помогает соблюсти LSP. Опишите, какие зависимости и контракты меняются. ⭐⭐⭐
- Как отличить «корректное расширение поведения подкласса» от «изменения смысла базового типа»? Какие вопросы вы зададите при ревью? ⭐⭐
- Может ли подкласс возвращать более конкретный тип (covariant return) и при этом соблюдать LSP? В каких условиях это безопасно? ⭐⭐⭐
- Как вы будете тестировать соблюдение LSP? Опишите подход к тестам: какие свойства или сценарии должны выполняться для всех реализаций базового типа. ⭐⭐⭐
- Как LSP связано с проектированием интерфейсов в целом (и с ISP/OCP)? Объясните, как неправильная абстракция приводит к цепочке нарушений принципов. ⭐⭐⭐
- Приведите пример из реального домена (например, платёжные методы, аккаунты, кэш/репозиторий, файловые потоки), где естественное на первый взгляд наследование приводит к нарушению LSP. Предложите корректную модель. ⭐⭐⭐

### Принцип разделения интерфейса (ISP)

- Сформулируйте принцип ISP своими словами. Почему «клиенты не должны зависеть от методов, которые они не используют» — это про архитектуру, а не про удобство API? ⭐⭐
- Что именно считается «клиентом интерфейса» в контексте ISP? Приведите примеры клиентов на уровне классов, модулей и компонентов. ⭐⭐
- Объясните, почему «толстый» интерфейс увеличивает связанность системы, даже если лишние методы никогда не вызываются. ⭐⭐
- В примере `IMultiFunctionDevice`: какие конкретные зависимости являются лишними для функции `PrintReport` и почему это важно? ⭐
- Почему пустые реализации или `throw` в методах `Scan/Fax` у `SimplePrinter` — плохой признак? Как это связано с корректностью модели и качеством дизайна? ⭐⭐
- Опишите «каскадные изменения», возникающие из-за толстых интерфейсов. Приведите сценарий, где изменение одного метода ломает много несвязанных компонентов. ⭐⭐
- Как ISP влияет на тестируемость? ⭐⭐
- Чем отличается «интерфейс как роль» от «интерфейс как набор методов класса»? Приведите пример неправильного и правильного подхода. ⭐⭐
- Как понять, что интерфейс нужно разделять? Назовите 3–5 практических признаков нарушения ISP в проекте. ⭐⭐
- В исправленном решении (`IPrinter`, `IScanner`, `IFax`) почему `SimplePrinter` становится проще и надёжнее? Какие классы больше не обязаны меняться при расширении системы? ⭐⭐
- Как изменение `IFax` (например, добавление параметра или нового метода) влияет на клиентов, работающих только с `IPrinter`? Почему это считается выигрышем архитектуры? ⭐⭐
- Предложите альтернативный дизайн устройства печати/сканирования без множественного наследования интерфейсов. Когда такой подход может быть предпочтительнее? ⭐⭐⭐
- В каких случаях «слишком мелкие интерфейсы» могут стать проблемой? Опишите антипример чрезмерного применения ISP. ⭐⭐⭐
- Как вы находите баланс между «толстым» интерфейсом и «зоопарком» из десятков микр-интерфейсов? Какие критерии вы используете? ⭐⭐⭐
- Если исходный интерфейс принадлежит сторонней библиотеке и изменить его нельзя, как применить ISP через адаптер? Опишите структуру решения и границы ответственности. ⭐⭐⭐
- Как ISP связан с принципом единственной ответственности (SRP)? Можно ли сказать, что «толстый интерфейс» часто является симптомом нарушения SRP? Обоснуйте. ⭐⭐⭐
- Как ISP связан с принципом инверсии зависимостей (DIP)? Почему DIP без ISP иногда приводит к «абстракциям-монстрам»? ⭐⭐⭐
- Может ли интерфейс быть «толстым» и при этом не нарушать ISP? Приведите пример, когда широкий интерфейс оправдан и не создаёт лишних зависимостей. ⭐⭐⭐
- Представьте, что вы проводите код-ревью и видите интерфейс из 20 методов. Какие вопросы вы зададите автору, чтобы проверить соблюдение ISP? ⭐⭐
- Придумайте пример из реального домена (например, платежи, доставка, хранение файлов, игровые сущности), где разделение интерфейса по ролям существенно снижает связанность. Опишите до/после. ⭐⭐⭐


### Принцип инверсии зависимостей (DIP)

- Сформулируйте принцип инверсии зависимостей (DIP) своими словами. Чем он отличается от «просто использовать интерфейсы»? ⭐⭐
- Что такое «модуль верхнего уровня» и «модуль нижнего уровня»? Приведите примеры из реального приложения (UI, use case, БД, сеть и т.д.). ⭐⭐
- Почему зависимости от БД, UI, файловой системы и сетевых библиотек считаются «нестабильными»? Какие виды изменений чаще всего происходят в этих деталях? ⭐⭐
- Объясните идею «зависимости должны быть направлены на абстракции». Как это снижает хрупкость архитектуры? ⭐⭐
- В примере `AddUserUseCase -> SqlUserRepository`: перечислите минимум 3 проблемы такого дизайна с точки зрения DIP и сопровождения. ⭐⭐
- Почему вызов `Connect()` внутри use case является тревожным сигналом? Что он говорит о границах ответственности и зависимостях? ⭐⭐⭐
- В исправленном примере с `IUserRepository`: что именно стало «стабильной абстракцией» и почему она должна принадлежать верхнему уровню, а не инфраструктуре? ⭐⭐⭐
- Как изменится система, если завтра нужно заменить SQL на REST API или in-memory хранилище? Опишите, какие файлы/модули должны измениться при соблюдении DIP. ⭐⭐
- Объясните, почему «реализация зависит от абстракции, а не наоборот» — это инверсия направления зависимости. Что именно «инвертируется»? ⭐⭐⭐
- Чем DIP отличается от Dependency Injection (DI)? Можно ли соблюдать DIP без DI-контейнера? Приведите пример. ⭐⭐⭐
- Что такое «композиционный корень» (composition root) и зачем он нужен при соблюдении DIP? Где он обычно находится в приложении? ⭐⭐⭐
- Назовите способы управления созданием объектов при DIP: конструкторная инъекция, фабрики, DI-контейнер. В каких случаях вы выберете каждый из них? ⭐⭐⭐
- Что означает «стабильные абстракции»? Какие признаки помогают понять, что абстракция действительно стабильна и правильно выделена? ⭐⭐⭐
- Почему правило «не наследуйте конкретные классы» связано со стабильностью архитектуры? В чём риск наследования от изменчивой реализации? ⭐⭐⭐
- Приведите пример нарушения DIP через транзитивные зависимости (когда верхний уровень начинает “видеть” детали нижнего). Как вы бы это исправили? ⭐⭐⭐
- Как DIP влияет на тестируемость? Опишите, как вы протестируете `AddUserUseCase`, не поднимая реальную базу данных. ⭐⭐
- Приведите пример, когда абстракция выделена неправильно (слишком широкая или «техническая») и DIP приводит к усложнению. Как бы вы переработали дизайн? ⭐⭐⭐
- В каких случаях DIP может быть избыточным? Приведите пример небольшого проекта, где применение DIP ухудшит ситуацию, и объясните почему. ⭐⭐
- Как DIP связан с архитектурными стилями Clean Architecture / Hexagonal Architecture? Опишите, какие слои обычно защищаются от изменений и за счёт чего. ⭐⭐⭐
- Представьте, что вы делаете код-ревью. Какие вопросы и проверки вы используете, чтобы понять: зависимости направлены правильно и DIP соблюдён осознанно, а не «ради интерфейсов»? ⭐⭐⭐

### Domain-Driven Design - 1

- Объясните, почему DDD называют “способом мышления”, а не набором паттернов или фреймворком. ⭐
- Приведите пример системы, в которой есть domain, но подход DDD не используется. Как это проявится в коде и процессах команды? ⭐⭐
- Какие типичные симптомы “большого проекта” вы ожидаете увидеть, и почему они появляются? ⭐⭐
- “Технически хороший код ≠ хороший бизнес-код”. Раскройте мысль на примере: как может выглядеть “чистая” архитектура, которая плохо отражает бизнес? ⭐⭐
- Дайте определение domain. Чем domain отличается от “просто набора сущностей в базе данных”? ⭐
- Что такое domain model и почему она должна содержать поведение, а не только данные? ⭐
- Объясните разницу между domain model и database model. В каких случаях их структуры сознательно должны отличаться? ⭐⭐
- Объясните разницу между domain model и DTO/API model. Какие риски возникают при “смешивании ролей”? ⭐⭐
- Почему в DDD domain model считается “центром приложения”? Какие практические выгоды это даёт при изменениях требований? ⭐⭐
- Назовите признаки, по которым вы решите, что DDD оправдан: какие свойства домена и продукта должны присутствовать? ⭐⭐
- Назовите признаки, по которым вы решите, что DDD избыточен. Чем это может навредить проекту? ⭐
- Что входит в “стоимость DDD”? Какие организационные и инженерные дисциплины нужны, чтобы DDD не деградировал? ⭐⭐
- Сравните Strategic и Tactical DDD. Какие ошибки возникают, если начать “тактику” без “стратегии”? ⭐⭐
- Объясните принцип Domain-first. Как будет выглядеть проектирование “в обратном порядке”, и к чему это приводит? ⭐⭐
- Сравните богатую доменную модель и анемичную. По каким признакам в коде вы быстро распознаете анемичную модель? ⭐⭐

### Domain-Driven Design - 2

- Почему инварианты должны проверяться внутри домена, а не в UI/контроллере/SQL? Приведите пример инварианта и место его проверки. ⭐⭐
- Что такое “явные границы ответственности” в DDD? Как bounded context и aggregate помогают держать эти границы? ⭐⭐
- Что означает “изоляция домена от инфраструктуры”? Какие зависимости и конструкции являются “запахом” загрязнённого домена? ⭐⭐
- Что в DDD понимается под “эволюцией модели”? Как явные границы помогают безопасно проводить рефакторинг домена? ⭐⭐
- Дайте определение Ubiquitous Language. Как вы будете поддерживать его актуальность в команде на длинной дистанции? ⭐⭐
- “Один термин — одно значение”. Почему это правило работает внутри bounded context, и почему оно может не работать между контекстами? ⭐⭐
- Приведите примеры плохих и хороших названий в коде. Как вы объясните, что нейминг — не “косметика”, а инструмент дизайна? ⭐
- Что такое bounded context как “контейнер смысла”? Почему bounded context — это не просто папка/namespace в коде? ⭐⭐
- На примере e-commerce объясните, почему один термин (“Order/Заказ”) имеет разные значения в Sales/Billing/Shipping/Inventory/Reporting и почему нельзя слить это в один класс. ⭐⭐⭐
- Что такое Context Map и какую проблему он решает? Какие вопросы он помогает прояснить между командами? ⭐⭐
- Объясните направления зависимостей на Context Map: что означает “стрелка”, кто от кого зависит и кто адаптируется? ⭐⭐
- Сравните типы интеграции контекстов: Shared Kernel, Customer/Supplier, Conformist, ACL. Для каждого назовите типичный сценарий применения и главный риск. ⭐⭐⭐
- Объясните, почему bounded context и микросервис — не синонимы. В каких случаях один контекст разумно оставлять внутри модульного монолита? ⭐⭐
- Что такое Event Storming, какую роль он играет в DDD и почему его считают мостом от стратегического анализа к тактическому дизайну? ⭐⭐
- Объясните CQRS: в чём смысл разделения команд и запросов, почему read model ≠ domain model, и в каких случаях CQRS стоит избегать. ⭐⭐⭐
- 